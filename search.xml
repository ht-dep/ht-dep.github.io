<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python基础（一）]]></title>
    <url>%2F2018%2F03%2F27%2Fpython%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[python基础回顾演变先有类，再出现对象，对象生存在作用域; 理论1、一切都皆为对象，一切皆为对象的引用。2、只有对名字（变量名-变量）赋值的时候，才会变更引用关系。 变量1、变量是用一个变量名表示，变量名必须是大小写英文、数字和下划线（_）的组合，且不能用数字开头。2、变量是在内存中开辟的一个空间，实际表示是name(字符串):name.ref(内存地址)。3、我们通常将变量名代表变量，变量值代表关联对象。 类1、类就是类型：object是祖先类型。2、类型对象是自动生成的，类有且仅有一个实例。123int、type(1)&gt;&gt;&gt; type(1) is int&gt;&gt;&gt; True 对象1、对象：是类的实例。2、存活的实例对象都有唯一的id。3、每个实例对象都持有所属类型的指针。4、在内存中的标准头，包括引用计数cnt、类型type、其他等。 基础数据（对象）类型：1、不可变数据（对象）类型：string、tuple、numbers（int、float）2、可变数据（对象）类型：list、dict 名字空间(namespace)1、名字（变量名）、目标对象。 将变量（名字）与对象（内存里的）关联起来的容器。 名字空间默认使用字典（dict）的数据结构。 2、名字（变量名）的引用必须跟目标对象的引用关联起来。 简单理解：变量名（字符串）的引用关联了目标对象的引用。 名字空间里实质上是存在{name.ref:obj.ref}的关系。可以通过id(name),看到obj.ref。 3、名字（变量名）关联目标对象的引用关联表就存在于名字空间这个容器。 简单理解：变量名（字符串）关联了目标对象的数据结构（字典) 名字空间里我们看到的是{name:obj}； 我们这里只考虑name(字符串):obj(目标对象)，不考虑深层次的ref； 4、根据作用域的不同，分为全局名字空间和当前（局部）名字空间。—这里的当前更合适一些，当前是属于局部的； 作用域理论1）根据可变对象和不可变对象;2）根据只有赋值的时候,才会便能引用关系;3）同一作用域内，名字总属于单一名字空间，不会因其执行顺序将其引用到不同名字空间。4）默认形参存储在函数对象的defaults里。5）内存空间：Fast(局部变量)、DEREF（外层嵌套，闭包） 局部作用域里的变量—使用dis.dis模块反汇编查看作用域1234567891011121314151617T1 = &quot;1&quot; #不可变对象T2 = [] #可变对象###############局部环境读取##################def change_string(): print(T1) # 读取了全局变量T1 ,按照LEGB的顺序###############局部环境创建##################def change_string(): T1 = &quot;dsd&quot; # 创建了局部变量T1 ,创建正常###############局部环境读取，创建##################def change_string(): print(T1) # 报错 ---------局部环境读取 # 名字只属于一个名字空间，作用域解析根据LEGB就近原则，只属于当前局部作用域（局部名字空间）; # 因此，出现歧义，报错UnboundLocalError # 解决方法 可以把T1 使用global 声明为全局 T1 = &quot;111&quot; # 赋值 ----------局部环境读取 在一个作用域里面给一个变量赋值的时候，Python自动认为这个变量是这个作用域的本地变量，并屏蔽作用域外的同名的变量; 函数的参数12345678910111213141516171819###############默认形参##################def change_list(a=[]): &apos;&apos;&apos; 函数生成时，a的引用默认指向change_list的属性__defaults__,通过类的属性实现记录历史状态； 函数被调用时，如果传入参数，则a的引用指向传入的参数，发生引用变更； &apos;&apos;&apos; print(&quot;初始：&#123;&#125;&quot;.format(a)) a.append(&quot;5&quot;) a.append(&quot;6&quot;) a = [] # 赋值发生a的引用变更 print(&quot;然后：&#123;&#125;&quot;.format(a))if __name__ == &quot;__main__&quot;: print(change_list.__defaults__) # ([],) change_list() # 初始：[] 然后：[] change_list() # 初始：[&apos;5&apos;, &apos;6&apos;] 然后：[] print(change_list.__defaults__) # ([&apos;5&apos;, &apos;6&apos;, &apos;5&apos;, &apos;6&apos;],) 函数传入参数：意味着在函数的作用域内 创建了个局部变量，发生引用变更；函数生成时，形参名字（变量）的引用默认指向函数的defaults属性；函数被调用时，若传入参数，则形参名字的引用指向新传入的参数，若无，仍指向defaults；函数每次调用，实际上是在新的局部作用域里，重新生成新的变量； 引用、浅copy、深copy理论1）根据可变对象和不可变对象;2）根据只有赋值的时候,才会便能引用关系; 引用：指向同一个对象1a=5 b=a 就是引用，a、b指向同一个对象; ####2、浅copy：只复制对象内部的已有的名字引用;1234567891011121314151617a=[&quot;1&quot;,2,[1,2,3]]b=a.copy() # 只复制a已有对象的名字引用；就是b[0]指向a[0] ,b[1]指向a[1] ,b[2]指向a[2]########更改已有的名字引用,可变数据类型#########b[2].append(4) # b[2]更改后a[2]会保持一致；---b[2]是列表(可变类型),因为没有赋值，未发生引用变更print(a) # [&apos;1&apos;, 2, [1, 2, 3, 7]]print(b) # [&apos;1&apos;, 2, [1, 2, 3, 7]]########更改已有的名字引用,可变/不可变数据类型########b[2]=3 # b[2]更改后a[2]不会保持一致；---b[2]是数字(不可变类型), 因为赋值，发生了引用变更print(a) # [&apos;1&apos;, 2, [1, 2, 3, 7]]print(b) # [&apos;1&apos;, 2, 3]########更改未有的名字引用######################b.append(0) # b添加了新的名字引用，a不会保持一致；---浅copy只能同步更改，copy的已有的名字引用print(a) # [&apos;1&apos;, 2, [1, 2, 3, 7]]print(b) # [&apos;1&apos;, 2, [1, 2, 3, 7], 0] 深copy123from copy import deepcopya=[&quot;1&quot;,2,[1,2,3]]c=deepcopy(a) # 递归复制所有引用成员（而不是只复制引用）；c和a之间是独立的，没啥关系了，不会同步； 闭包闭包是指函数离开生成环境后，仍可记住并持续引用词法作用域的外部变量。 理论1）根据可变对象和不可变对象;2）根据只有赋值的时候,才会便能引用关系;3）闭包引起的环境变量叫做自由变量，保存在函数对象的closure属性里，从内存的Fast转到DEREF里； 普通的闭包1234567891011121314151617181920def func(): &apos;&apos;&apos; 方法返回了一个函数 函数内部需要外部的变量count count成为自由变量，引用指向代码对象的__closure__ &apos;&apos;&apos; # count = [0] count = 5 # 不可变对象 def foo(): # count[0] = count[0] + 1 num = count + 1 # fu() print(num) return foocc = func()print(cc.__closure__) # (&lt;cell at 0x052A2290: int object at 0x5B43D470&gt;,) 记住外部状态的闭包1234567891011121314151617181920212223def func(): &apos;&apos;&apos; 方法返回了一个函数 函数内部需要外部的变量count count成为自由变量，引用指向代码对象的__closure__ &apos;&apos;&apos; count = [0] # count = 5 # 不可变对象 def foo(): count[0] = count[0] + 1 # num = count + 1 # fu() print(count) return foocc = func()print(cc.__closure__) # (&lt;cell at 0x052A2290: int object at 0x5B43D470&gt;,)cc() # [1]cc() # [2] 传递函数的闭包12345678910111213141516171819202122232425262728def fu(): print(&quot;inner&quot;)def func(fun): &apos;&apos;&apos; 传入的参数，创建fun指向它，并因为foo的调用，成为自由变量 方法返回了一个函数 函数内部需要外部的变量count count成为自由变量，引用指向代码对象的__closure__ &apos;&apos;&apos; count = [0] # count = 5 # 不可变对象 def foo(): count[0] = count[0] + 1 # num = count + 1 fun() print(count) return foocc = func(fu)print(cc.__closure__) # (&lt;cell at 0x052A2290: int object at 0x5B43D470&gt;,)cc() # inner [1]cc() # inner [2] 装饰器其实就是利用了闭包的这种方式实现的。 装饰器原理就是利用闭包在函数里传入一个函数对象，函数对象在闭包里调用。 无参装饰器1234567891011121314151617def w1(func): def inner(): # 验证1 # 验证2 # 验证3 return func() return inner#方法一：def f1(): print &apos;f1&apos;cc=w1(f1)cc()#方法二：@w1def f1(): print &apos;f1&apos;f1() 带参装饰器123456789101112131415def w2(av)： def w1(func): def inner(): # 验证1 # 验证2 # 验证3 print(av) return func() return inner return w1@w1(&apos;autor&apos;)def f1(): print &apos;f1&apos;f1() 带参的装饰器，就是又加了一层嵌套]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[IO多路复用模块selectors]]></title>
    <url>%2F2018%2F03%2F26%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9D%97selectors%2F</url>
    <content type="text"><![CDATA[IO多路复用IO多路复用就是我们经常说的select epoll.select和epoll，好处是单个process就可以同时处理多个网络IO。基本原理是select\epoll会不断的轮询所负责的所有socket，当有某个socket数据到达了，就通知用户进程。 在同一个线程里面，接收多个连接，select/epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 文件描述符fd: 为打开文件的文件描述符，而每个进程都有一张文件描述符表，fd文件描述符就是这张表的索引，同样这张表中有一表项，该表项又是指向前面提到打开文件的file结构体，file结构体才是内核中用来描述文件属性的结构体。我们都知道在Linux下一切皆文件。当然设备也不例外，如果要对某个设备进行操作，就不得不打开此设备文件，打开文件就会获得该文件的文件描述符fd( file discriptor), 它就是一个很小的整数。 IO多路复用： 事件循环不断地调用select获取被激光的socket，然后根据获取socket对应的EventHandler，执行Handle_event函数即可。因为select()会阻塞，因此只能被称为异步阻塞IO，而非真正的异步IO； asyncio协程： 根据事件驱动写的异步框架； 个人总结： 将不阻塞（原阻塞）的方法，注册进IO事件循环里—手动写； 外部loop，调用select()阻塞loop，等待被调用（然后执行具体逻辑操作）—手动写； 内部kernel不停地轮询注册进IO事件的文件对象，一旦有文件对象调用，则触发2里的select()，执行下一步（本质就是往select阻塞的那个队列里塞了个数据）—内部自动，看不见； Selectors主要对象类的层次结构123456BaseSelector+-- SelectSelector+-- PollSelector+-- EpollSelector+-- DevpollSelector+-- KqueueSelector 在下文中，事件 是指那些等待I/O 事件的给定的文件对象的位掩码（可读/可写）。它可以是下面的模块常量的组合︰12EVENT_READ 可读EVENT_WRITE 可写 SelectorKey —文件对象+文件描述符fd，可读/可写事件，文件对象相关联的回调函数 是一个用来将文件对象关联到其底层文件描述符，选定的事件掩码和附加的数据的 namedtuple。它由 BaseSelector 的几种方法返回。 1234567891011fileobj注册的文件对象。fd底层的文件描述符。events该文件对象必须等待的事件。data可选的与此文件对象相关联的不透明数据︰ 例如，这可以用来存储每个客户端的会话 id BaseSelector —多个文件对象的IO事件 的操作选择器类，返回类型是SelectorKey实例 register(fileobj, events, data=None) —注册文件对象、可读/可写、回调函数，data就是回调函数 注册一个文件对象到选择器来监视它的 I/O 事件 123fileobj 是要监视的文件对象。它可能是一个整型文件描述符或有 fileno() 方法的对象。events 是要监视的事件的位掩码。data 是不透明的对象。这返回一个新的 SelectorKey 实例，或者因无效的事件掩码或文件描述符抛出 ValueError 错误，或者如果文件对象已注册则抛出 KeyError 错误。 unregister(fileobj) —注销文件对象 从选择器注销一个文件对象并移除对它的监视。文件对象被注销前应先关闭 12fileobj 必须是先前注册过的文件对象。这返回关联的 SelectorKey 实例，或者如果 fileobj未注册则抛出 KeyError错误。如果 fileobj 无效则抛出ValueError错误（例如，它没有 fileno() 方法或其 fileno() 方法有无效的返回值）。 select(timeout=None) —阻塞，等待触发事件列表里 文件对象被触发，返回文件对象列表 等到一些已注册的文件对象准备好或者超时。如果 timeout &gt; 0，会指定最长的等待时间，以秒为单位。如果 timeout &lt; = 0，调用不会阻塞并会报告目前准备好的文件对象。如果 timeout 是 None，调用将会阻塞直到一个监视的文件对象准备好。 123这将返回一个以 (key, events) 元组为元素的列表，每一个元组代表一个准备好的文件对象。key 是对应于一个准备好的文件对象的SelectorKey 实例。events 是该文件对象上准备好的事件位掩码。 代码实现TCP Server 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import selectorsimport socket# 默认选择器类型select/epoll，返回一个选择器；用来操作IO事件sel = selectors.DefaultSelector()sock = socket.socket()sock.bind((&apos;127.0.0.1&apos;, 8800))sock.listen(5)sock.setblocking(False) # 设置socket为不阻塞############################################################### 子socket的handle处理方法--回调方法# conn--文件对象子socket，mask--文件对象的事件（可读/可写）##############################################################def read(conn, mask): try: data = conn.recv(1024) print(data.decode(&apos;utf-8&apos;)) print(&quot;接收到：&#123;&#125;&quot;.format(data)) data2 = &quot;xxxxxxx&quot; print(&quot;发送数据：&#123;&#125;&quot;.format(data2)) conn.send(data2.encode(&quot;utf-8&quot;)) except Exception as e: # 注销掉事件：client断开时，出发异常将该子socket文件对象从IO事件列表移除（注销） sel.unregister(conn)############################################################### 主socket的handle方法--回调方法，主要aceept接收socket客户端，# so--文件对象主socket，mask--文件对象的事件（可读/可写）##############################################################def accept(so, mask): conn, addr = so.accept() print(&quot;-----------&quot;, conn) # 注册子socket文件对象，事件，回调函数（上面的read方法） sel.register(conn, selectors.EVENT_READ, read)# 注册主socket事件，事件（可读/可写），回调函数sel.register(sock, selectors.EVENT_READ, accept)while 1: print(&quot;waiting.....&quot;) # 阻塞，等待任意一个文件对象被触发，返回文件对象列表 events = sel.select() for key, mask in events: &apos;&apos;&apos; 遍历获得 被触发文件对象，并通过获取文件对象关联的回调方法，执行回调； 在这里可以进行过滤，判断不同的文件对象，是否进行不同的操作； &apos;&apos;&apos; print(key.fileobj) # 文件对象 print(key.fd) # 文件对象 关联的 文件描述符fd func = key.data # 文件对象关联的回调函数 obj = key.fileobj # 文件对象 func(obj, mask) # 执行回调方法 IO模型（课外阅读）IO 多路复用是5种I/O模型中的第3种，对各种模型讲个故事，描述下区别：故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。 阻塞I/O模型老李去火车站买票，排队三天买到一张退票。耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 非阻塞I/O模型老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。耗费：往返车站6次，路上6小时，其他时间做了好多事。 I/O复用模型 select/poll老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次 epoll老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话 区别 1、epoll内部使用了mmap共享了用户和内核的部分空间，避免了数据的来回拷贝； 2、epoll基于事件驱动，epoll_ctl注册事件并注册callback回调函数，epoll_wait只返回发生的事件避免了像select和poll对事件的整个轮寻操作。nginx中使用了epoll，是基于事件驱动模型的，由一个或多个事件收集器来收集或者分发事件，epoll就属于事件驱动模型的事件收集器，将注册过的事件中发生的事件收集起来，master进程负责管理worker进程。 信号驱动I/O模型老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话 异步I/O模型老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话 1同2的区别是：自己轮询2同3的区别是：委托黄牛3同4的区别是：电话代替黄牛4同5的区别是：电话通知是自取还是送票上门 事件驱动模型（课外阅读）在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点： CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？ 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘； 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；所以，该方式是非常不好的。 方式二：就是事件驱动模型目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下： 有一个事件（消息）队列； 鼠标按下时，往这个队列中增加一个点击事件（消息）； 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等； 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数； 事件驱动编程是一种编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>异步</tag>
        <tag>selectors</tag>
        <tag>事件驱动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础总结]]></title>
    <url>%2F2018%2F03%2F25%2FPython%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Table of Contents Python语言特性 1 Python的函数参数传递 2 Python中的元类(metaclass) 3 @staticmethod和@classmethod 4 类变量和实例变量 5 Python自省 6 字典推导式 7 Python中单下划线和双下划线 8 字符串格式化:\x和.format 9 迭代器和生成器 10 *args and **kwargs 11 面向切面编程AOP和装饰器 12 鸭子类型 13 Python中重载 14 新式类和旧式类 15 new和init的区别 16 单例模式 1 使用new方法 2 共享属性 3 装饰器版本 4 import方法 17 Python中的作用域 18 GIL线程全局锁 19 协程 20 闭包 21 lambda函数 22 Python函数式编程 23 Python里的拷贝 24 Python垃圾回收机制 1 引用计数 2 标记-清除机制 3 分代技术 25 Python的List 26 Python的is 27 read,readline和readlines 28 Python2和3的区别 29 super init 30 range and xrange 操作系统 1 select,poll和epoll 2 调度算法 3 死锁 4 程序编译与链接 1 预处理 2 编译 3 汇编 4 链接 5 静态链接和动态链接 6 虚拟内存技术 7 分页和分段 分页与分段的主要区别 8 页面置换算法 9 边沿触发和水平触发 数据库 1 事务 2 数据库索引 3 Redis原理 Redis是什么？ Redis数据库 Redis缺点 4 乐观锁和悲观锁 5 MVCC MySQL的innodb引擎是如何实现MVCC的 6 MyISAM和InnoDB 网络 1 三次握手 2 四次挥手 3 ARP协议 4 urllib和urllib2的区别 5 Post和Get 6 Cookie和Session 7 apache和nginx的区别 8 网站用户密码保存 9 HTTP和HTTPS 10 XSRF和XSS 11 幂等 Idempotence 12 RESTful架构(SOAP,RPC) 13 SOAP 14 RPC 15 CGI和WSGI 16 中间人攻击 17 c10k问题 18 socket 19 浏览器缓存 20 HTTP1.0和HTTP1.1 21 Ajax *NIX unix进程间通信方式(IPC) 数据结构 1 红黑树 编程题 1 台阶问题/斐波那契 2 变态台阶问题 3 矩形覆盖 4 杨氏矩阵查找 5 去除列表中的重复元素 6 链表成对调换 7 创建字典的方法 1 直接创建 2 工厂方法 3 fromkeys()方法 8 合并两个有序列表 9 交叉链表求交点 10 二分查找 11 快排 12 找零问题 13 广度遍历和深度遍历二叉树 17 前中后序遍历 18 求最大树深 19 求两棵树是否相同 20 前序中序求后序 21 单链表逆置 22 两个字符串是否是变位词 23 动态规划问题 Python语言特性1 Python的函数参数传递看两个例子: 12345a = 1def fun(a): a = 2fun(a)print a # 1 12345a = []def fun(a): a.append(1)fun(a)print a # [1] 所有的变量都可以理解是内存中一个对象的“引用”，或者，也可以看似c中void*的感觉。 通过id来看引用a的内存地址可以比较理解： 12345678a = 1def fun(a): print "func_in",id(a) # func_in 41322472 a = 2 print "re-point",id(a), id(2) # re-point 41322448 41322448print "func_out",id(a), id(1) # func_out 41322472 41322472fun(a)print a # 1 注：具体的值在不同电脑上运行时可能不同。 可以看到，在执行完a = 2之后，a引用中保存的值，即内存地址发生变化，由原来1对象的所在的地址变成了2这个实体对象的内存地址。 而第2个例子a引用保存的内存值就不会发生变化： 1234567a = []def fun(a): print "func_in",id(a) # func_in 53629256 a.append(1)print "func_out",id(a) # func_out 53629256fun(a)print a # [1] 这里记住的是类型是属于对象的，而不是变量。而对象有两种,“可更改”（mutable）与“不可更改”（immutable）对象。在python中，strings, tuples, 和numbers是不可更改的对象，而 list, dict, set 等则是可以修改的对象。(这就是这个问题的重点) 当一个引用传递给函数的时候,函数自动复制一份引用,这个函数里的引用和外边的引用没有半毛关系了.所以第一个例子里函数把引用指向了一个不可变对象,当函数返回的时候,外面的引用没半毛感觉.而第二个例子就不一样了,函数内的引用指向的是可变对象,对它的操作就和定位了指针地址一样,在内存里进行修改. 如果还不明白的话,这里有更好的解释: http://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference 2 Python中的元类(metaclass)这个非常的不常用,但是像ORM这种复杂的结构还是会需要的,详情请看:http://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python 3 @staticmethod和@classmethodPython其实有3个方法,即静态方法(staticmethod),类方法(classmethod)和实例方法,如下: 12345678910111213141516def foo(x): print "executing foo(%s)"%(x)class A(object): def foo(self,x): print "executing foo(%s,%s)"%(self,x) @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) @staticmethod def static_foo(x): print "executing static_foo(%s)"%xa=A() 这里先理解下函数参数里面的self和cls.这个self和cls是对类或者实例的绑定,对于一般的函数来说我们可以这么调用foo(x),这个函数就是最常用的,它的工作跟任何东西(类,实例)无关.对于实例方法,我们知道在类里每次定义方法的时候都需要绑定这个实例,就是foo(self, x),为什么要这么做呢?因为实例方法的调用离不开实例,我们需要把实例自己传给函数,调用的时候是这样的a.foo(x)(其实是foo(a, x)).类方法一样,只不过它传递的是类而不是实例,A.class_foo(x).注意这里的self和cls可以替换别的参数,但是python的约定是这俩,还是不要改的好. 对于静态方法其实和普通的方法一样,不需要对谁进行绑定,唯一的区别是调用的时候需要使用a.static_foo(x)或者A.static_foo(x)来调用. \ 实例方法 类方法 静态方法 a = A() a.foo(x) a.class_foo(x) a.static_foo(x) A 不可用 A.class_foo(x) A.static_foo(x) 更多关于这个问题: http://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python https://realpython.com/blog/python/instance-class-and-static-methods-demystified/4 类变量和实例变量 类变量： ​ 是可在类的所有实例之间共享的值（也就是说，它们不是单独分配给每个实例的）。例如下例中，num_of_instance 就是类变量，用于跟踪存在着多少个Test 的实例。 实例变量： 实例化之后，每个实例单独拥有的变量。 12345678910111213class Test(object): num_of_instance = 0 def __init__(self, name): self.name = name Test.num_of_instance += 1if __name__ == '__main__': print Test.num_of_instance # 0 t1 = Test('jack') print Test.num_of_instance # 1 t2 = Test('lucy') print t1.name , t1.num_of_instance # jack 2 print t2.name , t2.num_of_instance # lucy 2 补充的例子 123456789class Person: name="aaa"p1=Person()p2=Person()p1.name="bbb"print p1.name # bbbprint p2.name # aaaprint Person.name # aaa 这里p1.name=&quot;bbb&quot;是实例调用了类变量,这其实和上面第一个问题一样,就是函数传参的问题,p1.name一开始是指向的类变量name=&quot;aaa&quot;,但是在实例的作用域里把类变量的引用改变了,就变成了一个实例变量,self.name不再引用Person的类变量name了. 可以看看下面的例子: 123456789class Person: name=[]p1=Person()p2=Person()p1.name.append(1)print p1.name # [1]print p2.name # [1]print Person.name # [1] 参考:http://stackoverflow.com/questions/6470428/catch-multiple-exceptions-in-one-line-except-block 5 Python自省这个也是python彪悍的特性. 自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance(). 12345a = [1,2,3]b = &#123;'a':1,'b':2,'c':3&#125;c = Trueprint type(a),type(b),type(c) # &lt;type 'list'&gt; &lt;type 'dict'&gt; &lt;type 'bool'&gt;print isinstance(a,list) # True 6 字典推导式可能你见过列表推导时,却没有见过字典推导式,在2.7中才加入的: 1d = &#123;key: value for (key, value) in iterable&#125; 7 Python中单下划线和双下划线1234567891011121314&gt;&gt;&gt; class MyClass():... def __init__(self):... self.__superprivate = "Hello"... self._semiprivate = ", world!"...&gt;&gt;&gt; mc = MyClass()&gt;&gt;&gt; print mc.__superprivateTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: myClass instance has no attribute '__superprivate'&gt;&gt;&gt; print mc._semiprivate, world!&gt;&gt;&gt; print mc.__dict__&#123;'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'&#125; __foo__:一种约定,Python内部的名字,用来区别其他用户自定义的命名,以防冲突，就是例如__init__(),__del__(),__call__()这些特殊方法 _foo:一种约定,用来指定变量私有.程序员用来指定私有变量的一种方式.不能用from module import * 导入，其他方面和公有一样访问； __foo:这个有真正的意义:解析器用_classname__foo来代替这个名字,以区别和其他类相同的命名,它无法直接像公有成员一样随便访问,通过对象名._类名__xxx这样的方式可以访问. 详情见:http://stackoverflow.com/questions/1301346/the-meaning-of-a-single-and-a-double-underscore-before-an-object-name-in-python 或者: http://www.zhihu.com/question/19754941 8 字符串格式化:%和.format.format在许多方面看起来更便利.对于%最烦人的是它无法同时传递一个变量和元组.你可能会想下面的代码不会有什么问题: 1&quot;hi there %s&quot; % name 但是,如果name恰好是(1,2,3),它将会抛出一个TypeError异常.为了保证它总是正确的,你必须这样做: 1&quot;hi there %s&quot; % (name,) # 提供一个单元素的数组而不是一个参数 但是有点丑..format就没有这些问题.你给的第二个问题也是这样,.format好看多了. 你为什么不用它? 不知道它(在读这个之前) 为了和Python2.5兼容(譬如logging库建议使用%(issue #4)) http://stackoverflow.com/questions/5082452/python-string-formatting-vs-format 9 迭代器和生成器这个是stackoverflow里python排名第一的问题,值得一看: http://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python 这是中文版: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html 这里有个关于生成器的创建问题面试官有考：问： 将列表生成式中[]改成() 之后数据结构是否改变？答案：是，从列表变为生成器 123456&gt;&gt;&gt; L = [x*x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x*x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x0000028F8B774200&gt; 通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—&gt;generator 10 *args and **kwargs用*args和**kwargs只是为了方便并没有强制使用它们. 当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数: 12345678&gt;&gt;&gt; def print_everything(*args): for count, thing in enumerate(args):... print '&#123;0&#125;. &#123;1&#125;'.format(count, thing)...&gt;&gt;&gt; print_everything('apple', 'banana', 'cabbage')0. apple1. banana2. cabbage 相似的,**kwargs允许你使用没有事先定义的参数名: 1234567&gt;&gt;&gt; def table_things(**kwargs):... for name, value in kwargs.items():... print '&#123;0&#125; = &#123;1&#125;'.format(name, value)...&gt;&gt;&gt; table_things(apple = 'fruit', cabbage = 'vegetable')cabbage = vegetableapple = fruit 你也可以混着用.命名参数首先获得参数值然后所有的其他参数都传递给*args和**kwargs.命名参数在列表的最前端.例如: 1def table_things(titlestring, **kwargs) *args和**kwargs可以同时在函数的定义中,但是*args必须在**kwargs前面. 当调用函数时你也可以用*和**语法.例如: 1234567&gt;&gt;&gt; def print_three_things(a, b, c):... print 'a = &#123;0&#125;, b = &#123;1&#125;, c = &#123;2&#125;'.format(a,b,c)...&gt;&gt;&gt; mylist = ['aardvark', 'baboon', 'cat']&gt;&gt;&gt; print_three_things(*mylist)a = aardvark, b = baboon, c = cat 就像你看到的一样,它可以传递列表(或者元组)的每一项并把它们解包.注意必须与它们在函数里的参数相吻合.当然,你也可以在函数定义或者函数调用时用*. http://stackoverflow.com/questions/3394835/args-and-kwargs 11 面向切面编程AOP和装饰器这个AOP一听起来有点懵,同学面阿里的时候就被问懵了… 装饰器是一个很著名的设计模式，经常被用于有切面需求的场景，较为经典的有插入日志、性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。 这个问题比较大,推荐: http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python 中文: http://taizilongxu.gitbooks.io/stackoverflow-about-python/content/3/README.html 12 鸭子类型“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。” 我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等. 鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。 13 Python中重载引自知乎:http://www.zhihu.com/question/20053359 函数重载主要是为了解决两个问题。 可变参数类型。 可变参数个数。 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。 好吧，那么对于情况 1 ，函数功能相同，但是参数类型不同，python 如何处理？答案是根本不需要处理，因为 python 可以接受任何类型的参数，如果函数的功能相同，那么不同的参数类型在 python 中很可能是相同的代码，没有必要做成两个不同函数。 那么对于情况 2 ，函数功能相同，但参数个数不同，python 如何处理？大家知道，答案就是缺省参数。对那些缺少的参数设定为缺省参数即可解决问题。因为你假设函数功能相同，那么那些缺少的参数终归是需要用的。 好了，鉴于情况 1 跟 情况 2 都有了解决方案，python 自然就不需要函数重载了。 14 新式类和旧式类这个面试官问了,我说了老半天,不知道他问的真正意图是什么. stackoverflow 这篇文章很好的介绍了新式类的特性: http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html 新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类是广度优先,旧式类是深度优先),&lt;Python核心编程&gt;里讲的也很多. 一个旧式类的深度优先的例子 12345678910111213141516class A(): def foo1(self): print "A"class B(A): def foo2(self): passclass C(A): def foo1(self): print "C"class D(B, C): passd = D()d.foo1()# A 按照经典类的查找顺序从左到右深度优先的规则，在访问d.foo1()的时候,D这个类是没有的..那么往上查找,先找到B,里面没有,深度优先,访问A,找到了foo1(),所以这时候调用的是A的foo1()，从而导致C重写的foo1()被绕过 15 __new__和__init__的区别这个__new__确实很少见到,先做了解吧. __new__是一个静态方法,而__init__是一个实例方法. __new__方法会返回一个创建的实例,而__init__什么都不返回. 只有在__new__返回一个cls的实例时后面的__init__才能被调用. 当创建一个新实例时调用__new__,初始化一个实例时用__init__. stackoverflow ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,实例创建和实例初始化的时候做一些小手脚. 16 单例模式 ​ 单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。 __new__()在__init__()之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的. 1 使用__new__方法123456789class Singleton(object): def __new__(cls, *args, **kw): if not hasattr(cls, '_instance'): orig = super(Singleton, cls) cls._instance = orig.__new__(cls, *args, **kw) return cls._instanceclass MyClass(Singleton): a = 1 2 共享属性创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法. 12345678910class Borg(object): _state = &#123;&#125; def __new__(cls, *args, **kw): ob = super(Borg, cls).__new__(cls, *args, **kw) ob.__dict__ = cls._state return obclass MyClass2(Borg): a = 1 3 装饰器版本1234567891011def singleton(cls, *args, **kw): instances = &#123;&#125; def getinstance(): if cls not in instances: instances[cls] = cls(*args, **kw) return instances[cls] return getinstance@singletonclass MyClass: ... 4 import方法作为python的模块是天然的单例模式 1234567891011# mysingleton.pyclass My_Singleton(object): def foo(self): passmy_singleton = My_Singleton()# to usefrom mysingleton import my_singletonmy_singleton.foo() 单例模式伯乐在线详细解释 17 Python中的作用域Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索： 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in） 18 GIL线程全局锁线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。 见Python 最难的问题 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能). 19 协程知乎被问到了,呵呵哒,跪了 简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态. Python里最常见的yield就是协程的思想!可以查看第九个问题. 20 闭包闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。 当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点: 必须有一个内嵌函数 内嵌函数必须引用外部函数中的变量 外部函数的返回值必须是内嵌函数 感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料. 重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上. 闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样. 21 lambda函数其实就是一个匿名函数,为什么叫lambda?因为和后面的函数式编程有关. 推荐: 知乎 22 Python函数式编程这个需要适当的了解一下吧,毕竟函数式编程在Python中也做了引用. 推荐: 酷壳 python中函数式编程支持: filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。 1234&gt;&gt;&gt;a = [1,2,3,4,5,6,7]&gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a)&gt;&gt;&gt;print b&gt;&gt;&gt;[6,7] map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2： 123&gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3])&gt;&gt;&gt; list(a)[2, 4, 6] reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘： 12&gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4))6 23 Python里的拷贝引用和copy(),deepcopy()的区别 1234567891011121314151617181920import copya = [1, 2, 3, 4, ['a', 'b']] #原始对象b = a #赋值，传对象的引用c = copy.copy(a) #对象拷贝，浅拷贝d = copy.deepcopy(a) #对象拷贝，深拷贝a.append(5) #修改对象aa[4].append('c') #修改对象a中的['a', 'b']数组对象print 'a = ', aprint 'b = ', bprint 'c = ', cprint 'd = ', d输出结果：a = [1, 2, 3, 4, ['a', 'b', 'c'], 5]b = [1, 2, 3, 4, ['a', 'b', 'c'], 5]c = [1, 2, 3, 4, ['a', 'b', 'c']]d = [1, 2, 3, 4, ['a', 'b']] 24 Python垃圾回收机制Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation collection）以空间换时间的方法提高垃圾回收效率。 1 引用计数PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。 优点: 简单 实时性 缺点: 维护引用计数消耗资源 循环引用 2 标记-清除机制基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。 3 分代技术分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。 Python默认定义了三代对象集合，索引数越大，对象存活时间越长。 举例：当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。 25 Python的List推荐: http://www.jianshu.com/p/J4U6rR 26 Python的isis是对比地址,==是对比值 27 read,readline和readlines read 读取整个文件 readline 读取下一行,使用生成器方法 readlines 读取整个文件到一个迭代器以供我们遍历 28 Python2和3的区别推荐：Python 2.7.x 与 Python 3.x 的主要差异 29 super initsuper() lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven’t already. Note that the syntax changed in Python 3.0: you can just say super().__init__() instead of super(ChildB, self).__init__() which IMO is quite a bit nicer. http://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods Python2.7中的super方法浅见 30 range and xrange都在循环时使用，xrange内存性能更好。for i in range(0, 20):for i in xrange(0, 20):What is the difference between range and xrange functions in Python 2.X? range creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements. xrange is a sequence object that evaluates lazily. http://stackoverflow.com/questions/94935/what-is-the-difference-between-range-and-xrange-functions-in-python-2-x 操作系统1 select,poll和epoll其实所有的I/O都是轮询的方法,只不过实现的层面不同罢了. 这个问题可能有点深入了,但相信能回答出这个问题是对I/O多路复用有很好的了解了.其中tornado使用的就是epoll的. selec,poll和epoll区别总结 基本上select有3个缺点: 连接数受限 查找配对速度慢 数据由内核拷贝到用户态 poll改善了第一个缺点 epoll改了三个缺点. 关于epoll的: http://www.cnblogs.com/my_life/articles/3968782.html 2 调度算法 先来先服务(FCFS, First Come First Serve) 短作业优先(SJF, Shortest Job First) 最高优先权调度(Priority Scheduling) 时间片轮转(RR, Round Robin) 多级反馈队列调度(multilevel feedback queue scheduling) 常见的调度算法总结:http://www.jianshu.com/p/6edf8174c1eb 实时调度算法: 最早截至时间优先 EDF 最低松弛度优先 LLF 3 死锁原因: 竞争资源 程序推进顺序不当 必要条件: 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 处理死锁基本方法: 预防死锁(摒弃除1以外的条件) 避免死锁(银行家算法) 检测死锁(资源分配图) 解除死锁 剥夺资源 撤销进程 死锁概念处理策略详细介绍:https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/10.html 4 程序编译与链接推荐: http://www.ruanyifeng.com/blog/2014/11/compiler.html Bulid过程可以分解为4个步骤:预处理(Prepressing), 编译(Compilation)、汇编(Assembly)、链接(Linking) 以c语言为例: 1 预处理预编译过程主要处理那些源文件中的以“#”开始的预编译指令，主要处理规则有： 将所有的“#define”删除，并展开所用的宏定义 处理所有条件预编译指令，比如“#if”、“#ifdef”、 “#elif”、“#endif” 处理“#include”预编译指令，将被包含的文件插入到该编译指令的位置，注：此过程是递归进行的 删除所有注释 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息以及用于编译时产生编译错误或警告时可显示行号 保留所有的#pragma编译器指令。 2 编译编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。这个过程是整个程序构建的核心部分。 3 汇编汇编器是将汇编代码转化成机器可以执行的指令，每一条汇编语句几乎都是一条机器指令。经过编译、链接、汇编输出的文件成为目标文件(Object File) 4 链接链接的主要内容就是把各个模块之间相互引用的部分处理好，使各个模块可以正确的拼接。链接的主要过程包块 地址和空间的分配（Address and Storage Allocation）、符号决议(Symbol Resolution)和重定位(Relocation)等步骤。 5 静态链接和动态链接静态链接方法：静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库 动态链接方法：使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序 6 虚拟内存技术虚拟存储器是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储系统. 7 分页和分段分页: 用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。 分段: 将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。 分页与分段的主要区别 页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要. 页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分. 分页的作业地址空间是一维的.分段的地址空间是二维的. 8 页面置换算法 最佳置换算法OPT:不可能实现 先进先出FIFO 最近最久未使用算法LRU:最近一段时间里最久没有使用过的页面予以置换. clock算法 9 边沿触发和水平触发边缘触发是指每当状态变化时发生一个 io 事件，条件触发是只要满足条件就发生一个 io 事件 数据库1 事务数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。彻底理解数据库事务: http://www.hollischuang.com/archives/898 2 数据库索引推荐: http://tech.meituan.com/mysql-index.html MySQL索引背后的数据结构及算法原理 聚集索引,非聚集索引,B-Tree,B+Tree,最左前缀原理 3 Redis原理Redis是什么？ 是一个完全开源免费的key-value内存数据库 通常被认为是一个数据结构服务器，主要是因为其有着丰富的数据结构 strings、map、 list、sets、 sorted sets Redis数据库 ​ 通常局限点来说，Redis也以消息队列的形式存在，作为内嵌的List存在，满足实时的高并发需求。在使用缓存的时候，redis比memcached具有更多的优势，并且支持更多的数据类型，把redis当作一个中间存储系统，用来处理高并发的数据库操作 速度快：使用标准C写，所有数据都在内存中完成，读写速度分别达到10万/20万 持久化：对数据的更新采用Copy-on-write技术，可以异步地保存到磁盘上，主要有两种策略，一是根据时间，更新次数的快照（save 300 10 ）二是基于语句追加方式(Append-only file，aof) 自动操作：对不同数据类型的操作都是自动的，很安全 快速的主–从复制，官方提供了一个数据，Slave在21秒即完成了对Amazon网站10G key set的复制。 Sharding技术： 很容易将数据分布到多个Redis实例中，数据库的扩展是个永恒的话题，在关系型数据库中，主要是以添加硬件、以分区为主要技术形式的纵向扩展解决了很多的应用场景，但随着web2.0、移动互联网、云计算等应用的兴起，这种扩展模式已经不太适合了，所以近年来，像采用主从配置、数据库复制形式的，Sharding这种技术把负载分布到多个特理节点上去的横向扩展方式用处越来越多。 Redis缺点 是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 4 乐观锁和悲观锁悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁与悲观锁的具体区别: http://www.cnblogs.com/Bob-FD/p/3352216.html 5 MVCC ​ 全称是Multi-Version Concurrent Control，即多版本并发控制，在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。 MySQL的innodb引擎是如何实现MVCC的innodb会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（事务的隔离级别请看这篇文章）下，具体各种数据库操作的实现： select：满足以下两个条件innodb会返回该行数据： 该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。 该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。 insert：将新插入的行的创建版本号设置为当前系统的版本号。 delete：将要删除的行的删除版本号设置为当前系统的版本号。 update：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。 ​ 由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做purge。 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。 参考：MVCC浅析 6 MyISAM和InnoDBMyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 mysql 数据库引擎: http://www.cnblogs.com/0201zcr/p/5296843.htmlMySQL存储引擎－－MyISAM与InnoDB区别: https://segmentfault.com/a/1190000008227211 网络1 三次握手 客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。 服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。 最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。 2 四次挥手注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然. 客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据. 服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息. 服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文. 客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接. 图解: http://blog.csdn.net/whuslei/article/details/6667471 3 ARP协议地址解析协议(Address Resolution Protocol)，其基本功能为透过目标设备的IP地址，查询目标的MAC地址，以保证通信的顺利进行。它是IPv4网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。 4 urllib和urllib2的区别这个面试官确实问过,当时答的urllib2可以Post而urllib不可以. urllib提供urlencode方法用来GET查询字符串的产生，而urllib2没有。这是为何urllib常和urllib2一起使用的原因。 urllib2可以接受一个Request类的实例来设置URL请求的headers，urllib仅可以接受URL。这意味着，你不可以伪装你的User Agent字符串等。 5 Post和GetGET和POST有什么区别？及为什么网上的多数答案都是错的知乎回答 get: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1post: RFC 2616 - Hypertext Transfer Protocol – HTTP/1.1 6 Cookie和Session Cookie Session 储存位置 客户端 服务器端 目的 跟踪会话，也可以保存用户偏好设置或者保存用户名密码等 跟踪会话 安全性 不安全 安全 session技术是要使用到cookie的，之所以出现session技术，主要是为了安全。 7 apache和nginx的区别nginx 相对 apache 的优点： 轻量级，同样起web 服务，比apache 占用更少的内存及资源 抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能 配置简洁 高度模块化的设计，编写模块相对简单 社区活跃 apache 相对nginx 的优点： rewrite ，比nginx 的rewrite 强大 模块超多，基本想到的都可以找到 少bug ，nginx 的bug 相对较多 超稳定 8 网站用户密码保存 明文保存 明文hash后保存,如md5 MD5+Salt方式,这个salt可以随机 知乎使用了Bcrypy(好像)加密 9 HTTP和HTTPS 状态码 定义 1xx 报告 接收到请求，继续进程 2xx 成功 步骤成功接收，被理解，并被接受 3xx 重定向 为了完成请求,必须采取进一步措施 4xx 客户端出错 请求包括错的顺序或不能完成 5xx 服务器出错 服务器无法完成显然有效的请求 403: Forbidden404: Not Found HTTPS握手,对称加密,非对称加密,TLS/SSL,RSA 10 XSRF和XSS CSRF(Cross-site request forgery)跨站请求伪造 XSS(Cross Site Scripting)跨站脚本攻击 CSRF重点在请求,XSS重点在脚本 11 幂等 IdempotenceHTTP方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。(注意是副作用) GET http://www.bank.com/account/123456，不会改变资源的状态，不论调用一次还是N次都没有副作用。请注意，这里强调的是一次和N次具有相同的副作用，而不是每次GET的结果相同。GET http://www.news.com/latest-news这个HTTP请求可能会每次得到不同的结果，但它本身并没有产生任何副作用，因而是满足幂等性的。 DELETE方法用于删除资源，有副作用，但它应该满足幂等性。比如：DELETE http://www.forum.com/article/4231，调用一次和N次对系统产生的副作用是相同的，即删掉id为4231的帖子；因此，调用者可以多次调用或刷新页面而不必担心引起错误。 POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。 PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 12 RESTful架构(SOAP,RPC)推荐: http://www.ruanyifeng.com/blog/2011/09/restful.html 13 SOAPSOAP（原为Simple Object Access Protocol的首字母缩写，即简单对象访问协议）是交换数据的一种协议规范，使用在计算机网络Web服务（web service）中，交换带结构信息。SOAP为了简化网页服务器（Web Server）从XML数据库中提取数据时，节省去格式化页面时间，以及不同应用程序之间按照HTTP通信协议，遵从XML格式执行资料互换，使其抽象于语言实现、平台和硬件。 14 RPCRPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。 总结:服务提供的两大流派.传统意义以方法调用为导向通称RPC。为了企业SOA,若干厂商联合推出webservice,制定了wsdl接口定义,传输soap.当互联网时代,臃肿SOA被简化为http+xml/json.但是简化出现各种混乱。以资源为导向,任何操作无非是对资源的增删改查，于是统一的REST出现了. 进化的顺序: RPC -&gt; SOAP -&gt; RESTful 15 CGI和WSGICGI是通用网关接口，是连接web服务器和应用程序的接口，用户通过CGI来获取动态数据或文件等。CGI程序是一个独立的程序，它可以用几乎所有语言来写，包括perl，c，lua，python等等。 WSGI, Web Server Gateway Interface，是Python应用程序或框架和Web服务器之间的一种接口，WSGI的其中一个目的就是让用户可以用统一的语言(Python)编写前后端。 官方说明：PEP-3333 16 中间人攻击在GFW里屡见不鲜的,呵呵. 中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。 17 c10k问题所谓c10k问题，指的是服务器同时支持成千上万个客户端的问题，也就是concurrent 10 000 connection（这也是c10k这个名字的由来）。推荐: https://my.oschina.net/xianggao/blog/664275 18 socket推荐: http://www.360doc.com/content/11/0609/15/5482098_122692444.shtml Socket=Ip address+ TCP/UDP + port 19 浏览器缓存推荐: http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html 304 Not Modified 20 HTTP1.0和HTTP1.1推荐: http://blog.csdn.net/elifefly/article/details/3964766 请求头Host字段,一个服务器多个网站 长链接 文件断点续传 身份认证,状态管理,Cache缓存 HTTP请求8种方法介绍HTTP/1.1协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GET GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。 GET会方法请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。 HEAD HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。 POST POST请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 PUT PUT请求会身向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 DELETE DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。 CONNECT CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 OPTIONS OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用’*’来代替资源名称，向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许 TRACE TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。 HTTP/1.1之后增加的方法 在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法： PATCH PATCH方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同： 但PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。 21 AjaxAJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。 *NIXunix进程间通信方式(IPC) 管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。 命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。 消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 数据结构1 红黑树红黑树与AVL的比较： AVL是严格平衡树，因此在增加或者删除节点的时候，根据不同情况，旋转的次数比红黑树要多； 红黑是用非严格的平衡来换取增删节点时候旋转次数的降低； 所以简单说，如果你的应用中，搜索的次数远远大于插入和删除，那么选择AVL，如果搜索，插入删除次数几乎差不多，应该选择RB。 红黑树详解: https://xieguanglei.github.io/blog/post/red-black-tree.html 教你透彻了解红黑树: https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/03.01.md 编程题1 台阶问题/斐波那契一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt;= 2 else fib(n - 1) + fib(n - 2) 第二种记忆方法 1234567891011121314def memo(func): cache = &#123;&#125; def wrap(*args): if args not in cache: cache[args] = func(*args) return cache[args] return wrap@memodef fib(i): if i &lt; 2: return 1 return fib(i-1) + fib(i-2) 第三种方法 12345def fib(n): a, b = 0, 1 for _ in xrange(n): a, b = b, a + b return b 2 变态台阶问题一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 1fib = lambda n: n if n &lt; 2 else 2 * fib(n - 1) 3 矩形覆盖我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 第2*n个矩形的覆盖方法等于第2*(n-1)加上第2*(n-2)的方法。 1f = lambda n: 1 if n &lt; 2 else f(n - 1) + f(n - 2) 4 杨氏矩阵查找在一个m行n列二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 使用Step-wise线性搜索。 1234567891011121314151617def get_value(l, r, c): return l[r][c]def find(l, x): m = len(l) - 1 n = len(l[0]) - 1 r = 0 c = n while c &gt;= 0 and r &lt;= m: value = get_value(l, r, c) if value == x: return True elif value &gt; x: c = c - 1 elif value &lt; x: r = r + 1 return False 5 去除列表中的重复元素用集合 1list(set(l)) 用字典 123l1 = ['b','c','d','b','c','a','a']l2 = &#123;&#125;.fromkeys(l1).keys()print l2 用字典并保持顺序 1234l1 = ['b','c','d','b','c','a','a']l2 = list(set(l1))l2.sort(key=l1.index)print l2 列表推导式 123l1 = ['b','c','d','b','c','a','a']l2 = [][l2.append(i) for i in l1 if not i in l2] sorted排序并且用列表推导式. l = [‘b’,’c’,’d’,’b’,’c’,’a’,’a’][single.append(i) for i in sorted(l) if i not in single]print single 6 链表成对调换1-&gt;2-&gt;3-&gt;4转换成2-&gt;1-&gt;4-&gt;3. 123456789101112131415class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: # @param a ListNode # @return a ListNode def swapPairs(self, head): if head != None and head.next != None: next = head.next head.next = self.swapPairs(next.next) next.next = head return next return head 7 创建字典的方法1 直接创建1dict = &#123;'name':'earth', 'port':'80'&#125; 2 工厂方法123items=[('name','earth'),('port','80')]dict2=dict(items)dict1=dict((['name','earth'],['port','80'])) 3 fromkeys()方法1234dict1=&#123;&#125;.fromkeys(('x','y'),-1)dict=&#123;'x':-1,'y':-1&#125;dict2=&#123;&#125;.fromkeys(('x','y'))dict2=&#123;'x':None, 'y':None&#125; 8 合并两个有序列表知乎远程面试要求编程 尾递归 12345678910111213141516def _recursion_merge_sort2(l1, l2, tmp): if len(l1) == 0 or len(l2) == 0: tmp.extend(l1) tmp.extend(l2) return tmp else: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] return _recursion_merge_sort2(l1, l2, tmp)def recursion_merge_sort2(l1, l2): return _recursion_merge_sort2(l1, l2, []) 循环算法 思路： 定义一个新的空列表 比较两个列表的首个元素 小的就插入到新列表里 把已经插入新列表的元素从旧列表删除 直到两个旧列表有一个为空 再把旧列表加到新列表后面 123456789101112def loop_merge_sort(l1, l2): tmp = [] while len(l1) &gt; 0 and len(l2) &gt; 0: if l1[0] &lt; l2[0]: tmp.append(l1[0]) del l1[0] else: tmp.append(l2[0]) del l2[0] tmp.extend(l1) tmp.extend(l2) return tmp pop弹出 12345678910111213141516a = [1,2,3,7]b = [3,4,5]def merge_sortedlist(a,b): c = [] while a and b: if a[0] &gt;= b[0]: c.append(b.pop(0)) else: c.append(a.pop(0)) while a: c.append(a.pop(0)) while b: c.append(b.pop(0)) return cprint merge_sortedlist(a,b) 9 交叉链表求交点 其实思想可以按照从尾开始比较两个链表，如果相交，则从尾开始必然一致，只要从尾开始比较，直至不一致的地方即为交叉点，如图所示 1234567891011121314# 使用a,b两个list来模拟链表，可以看出交叉点是 7这个节点a = [1,2,3,7,9,1,5]b = [4,5,7,9,1,5]for i in range(1,min(len(a),len(b))): if i==1 and (a[-1] != b[-1]): print "No" break else: if a[-i] != b[-i]: print "交叉节点：",a[-i+1] break else: pass 另外一种比较正规的方法，构造链表类 1234567891011121314151617181920212223242526class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, lenth2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next length1 += 1 while l2.next: l2 = l2.next length2 += 1 # 长的链表先走 if length1 &gt; lenth2: for _ in range(length1 - length2): l1 = l1.next else: for _ in range(length2 - length1): l2 = l2.next while l1 and l2: if l1.next == l2.next: return l1.next else: l1 = l1.next l2 = l2.next 修改了一下: 123456789101112131415161718192021222324252627282930#coding:utf-8class ListNode: def __init__(self, x): self.val = x self.next = Nonedef node(l1, l2): length1, length2 = 0, 0 # 求两个链表长度 while l1.next: l1 = l1.next#尾节点 length1 += 1 while l2.next: l2 = l2.next#尾节点 length2 += 1 #如果相交 if l1.next == l2.next: # 长的链表先走 if length1 &gt; length2: for _ in range(length1 - length2): l1 = l1.next return l1#返回交点 else: for _ in range(length2 - length1): l2 = l2.next return l2#返回交点 # 如果不相交 else: return 思路: http://humaoli.blog.163.com/blog/static/13346651820141125102125995/ 10 二分查找1234567891011121314151617#coding:utf-8def binary_search(list,item): low = 0 high = len(list)-1 while low&lt;=high: mid = (low+high)/2 guess = list[mid] if guess&gt;item: high = mid-1 elif guess&lt;item: low = mid+1 else: return mid return Nonemylist = [1,3,5,7,9]print binary_search(mylist,3) 参考: http://blog.csdn.net/u013205877/article/details/76411718 11 快排123456789101112#coding:utf-8def quicksort(list): if len(list)&lt;2: return list else: midpivot = list[0] lessbeforemidpivot = [i for i in list[1:] if i&lt;=midpivot] biggerafterpivot = [i for i in list[1:] if i &gt; midpivot] finallylist = quicksort(lessbeforemidpivot)+[midpivot]+quicksort(biggerafterpivot) return finallylistprint quicksort([2,4,6,7,1,2,5]) 更多排序问题可见：数据结构与算法-排序篇-Python描述 12 找零问题12345678910111213141516171819#coding:utf-8#values是硬币的面值values = [ 25, 21, 10, 5, 1]#valuesCounts 钱币对应的种类数#money 找出来的总钱数#coinsUsed 对应于目前钱币总数i所使用的硬币数目def coinChange(values,valuesCounts,money,coinsUsed): #遍历出从1到money所有的钱数可能 for cents in range(1,money+1): minCoins = cents #把所有的硬币面值遍历出来和钱数做对比 for kind in range(0,valuesCounts): if (values[kind] &lt;= cents): temp = coinsUsed[cents - values[kind]] +1 if (temp &lt; minCoins): minCoins = temp coinsUsed[cents] = minCoins print ('面值:&#123;0&#125;的最少硬币使用数为:&#123;1&#125;'.format(cents, coinsUsed[cents])) 思路: http://blog.csdn.net/wdxin1322/article/details/9501163 方法: http://www.cnblogs.com/ChenxofHit/archive/2011/03/18/1988431.html 13 广度遍历和深度遍历二叉树给定一个数组，构建二叉树，并且按层次打印这个二叉树 14 二叉树节点12345678class Node(object): def __init__(self, data, left=None, right=None): self.data = data self.left = left self.right = righttree = Node(1, Node(3, Node(7, Node(0)), Node(6)), Node(2, Node(5), Node(4))) 15 层次遍历123456def lookup(root): row = [root] while row: print(row) row = [kid for item in row for kid in (item.left, item.right) if kid] 16 深度遍历1234567891011def deep(root): if not root: return print root.data deep(root.left) deep(root.right)if __name__ == '__main__': lookup(tree) deep(tree) 17 前中后序遍历深度遍历改变顺序就OK了 12345678910111213141516171819202122232425262728293031323334353637#coding:utf-8#二叉树的遍历#简单的二叉树节点类class Node(object): def __init__(self,value,left,right): self.value = value self.left = left self.right = right#中序遍历:遍历左子树,访问当前节点,遍历右子树def mid_travelsal(root): if root.left is None: mid_travelsal(root.left) #访问当前节点 print(root.value) if root.right is not None: mid_travelsal(root.right)#前序遍历:访问当前节点,遍历左子树,遍历右子树def pre_travelsal(root): print (root.value) if root.left is not None: pre_travelsal(root.left) if root.right is not None: pre_travelsal(root.right)#后续遍历:遍历左子树,遍历右子树,访问当前节点def post_trvelsal(root): if root.left is not None: post_trvelsal(root.left) if root.right is not None: post_trvelsal(root.right) print (root.value) 18 求最大树深1234def maxDepth(root): if not root: return 0 return max(maxDepth(root.left), maxDepth(root.right)) + 1 19 求两棵树是否相同1234567def isSameTree(p, q): if p == None and q == None: return True elif p and q : return p.val == q.val and isSameTree(p.left,q.left) and isSameTree(p.right,q.right) else : return False 20 前序中序求后序推荐: http://blog.csdn.net/hinyunsin/article/details/6315502 123456789101112131415def rebuild(pre, center): if not pre: return cur = Node(pre[0]) index = center.index(pre[0]) cur.left = rebuild(pre[1:index + 1], center[:index]) cur.right = rebuild(pre[index + 1:], center[index + 1:]) return curdef deep(root): if not root: return deep(root.left) deep(root.right) print root.data 21 单链表逆置12345678910111213141516171819202122class Node(object): def __init__(self, data=None, next=None): self.data = data self.next = nextlink = Node(1, Node(2, Node(3, Node(4, Node(5, Node(6, Node(7, Node(8, Node(9)))))))))def rev(link): pre = link cur = link.next pre.next = None while cur: tmp = cur.next cur.next = pre pre = cur cur = tmp return preroot = rev(link)while root: print root.data root = root.next 思路: http://blog.csdn.net/feliciafay/article/details/6841115 方法: http://www.xuebuyuan.com/2066385.html?mobile=1 22 两个字符串是否是变位词12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class Anagram: """ @:param s1: The first string @:param s2: The second string @:return true or false """ def Solution1(s1,s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK print(Solution1('abcd','dcba')) def Solution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches print(Solution2('abcde','edcbg')) def Solution3(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j&lt;26 and stillOK: if c1[j] == c2[j]: j = j + 1 else: stillOK = False return stillOK print(Solution3('apple','pleap')) 23 动态规划问题 可参考：动态规划(DP)的整理-Python描述]]></content>
  </entry>
  <entry>
    <title><![CDATA[CentOS7修改时区]]></title>
    <url>%2F2018%2F03%2F22%2FCentOS7%E4%BF%AE%E6%94%B9%E6%97%B6%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[修改Linux硬件时钟查看时钟： timedatectl硬件时钟改为本地时间： Centos7 1timedatectl set-local-rtcl Debian9 1timedatectl set-timezone Asia/Shangha 定时同步时间 修改开机启动，添加定时任务在/etc/rc.d/rc.local里加入(如果没有执行权限，需要chmod +x rc.local)： 1/sbin/service crond start 创建定时任务,比如：每小时的15分钟 更新时间一次执行 crontab -e ,添加 115 * * * * ntpdate 10.17.251.1 查看定时任务 1crontab -l]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux文本浏览器]]></title>
    <url>%2F2018%2F03%2F21%2Flinux%E6%96%87%E6%9C%AC%E6%B5%8F%E8%A7%88%E5%99%A8%2F</url>
    <content type="text"><![CDATA[安装lynx–彩色yum install lynx -y 使用说明比较明确 安装links–黑白yum install links -y 比较早，c语言编写，Enter键， 鼠标Click，Esc键、Ctrl + C 退出 访问地址lynx https://pingendo.com]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>文本浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7部署supervisor和nginx]]></title>
    <url>%2F2018%2F03%2F19%2FCentOS7%E9%83%A8%E7%BD%B2supervisor%E5%92%8Cnginx%2F</url>
    <content type="text"><![CDATA[安装NGINX跟python的编译安装一摸一样12345tar -xf nginx-1.13.9.tar.gzcd nginx-1.13.9/./configure --prefix=/usr/nginxmakemake install 修改配置文件禁止后台启动，否则supervisor无法监控，出现nginx不停重启的问题1daemon off; 编写配置文件123456789101112131415161718192021222324252627location / &#123; root /home/html; index index.html index.htm;&#125;location /kl &#123; root /home/html; #静态资源在这里，因此static都要放在这里； proxy_pass http://127.0.0.1:9999/kl; proxy_redirect default; proxy_set_header Cookie $http_cookie; proxy_set_header Remote_Addr $remote_addr; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; index index.html index.htm;&#125; location /robot &#123; proxy_pass http://127.0.0.1:9999/robot; proxy_redirect default; proxy_set_header Cookie $http_cookie; proxy_set_header Remote_Addr $remote_addr; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; client_max_body_size 100m; index index.html index.htm;&#125; nginx相关命令12345重启nginx：/usr/nginx/sbin/nginx -s reopen重新加载配置文件：/usr/nginx/sbin/nginx -s reload启动：/usr/nginx/sbin/nginx关闭：/usr/nginx/sbin/nginx -s stop指定配置文件：/usr/nginx/sbin/nginx -c nginx.conf 安装supervisor123tar -xf supervisor-3.3.3.tar.gzcd supervisor-3.3.3python setup.py install 服务端指令：supervisord客户端指令：supervisorctl服务端执行配置文件：supervisord -c /home/startsh/supervisord.conf supervisor的配置文件里加入123456789[program:HT-NGINX]directory = /home/startshcommand = /usr/nginx/sbin/nginx -c /home/startsh/nginx.conf ; 指定启动文件autostart=trueautorestart=true ;如果NGINX异常退出，则重启startretries=3 ;最大重启次数redirect_stderr=true ; 重定向输出的日志stdout_logfile = /var/log/supervisord/HT-NGINX.logloglevel=info supervisor常用命令客户端执行配置文件：supervisorctrl -c /home/startsh/supervisord.conf12345678help # 查看帮助status # 查看程序状态reread # 更新配置，不重启应用update # 重启配置改动的应用stop program_name # 关闭 指定的程序start program_name # 启动 指定的程序restart program_name # 重启 指定的程序tail -f program_name # 查看 该程序的日志 阿里云、腾讯云SSH经常自动断开修改 /etc/ssh/sshd_config12ClientAliveInterval 30ClientAliveCountMax 86400 重启sshd服务： 1/bin/systemctl restart sshd.service 启动nginx时报错12[root@VM_81_66_centos ~]# /usr/nginx/sbin/nginx -c /home/startsh/nginx.confnginx: [emerg] open() &quot;/home/startsh/mime.types&quot; failed (2: No such file or directory) in /home/startsh/nginx.conf:18 解决方法：123http &#123; include /usr/nginx/conf/mime.types; //补全，填写含有mime.types的路径 default_type application/octet-stream;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>supervisor</tag>
        <tag>nginx</tag>
        <tag>腾讯云</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7定时更新时间]]></title>
    <url>%2F2018%2F03%2F19%2FCentOS7%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[同步时间1ntpdate xx.xxx.xx.x 测试用的两个时间服务器地址： ntpdate 223.65.211.42 — 慢一分钟 ntpdate 202.112.31.197 — 正常 添加cron开机自启动 在/etc/rc.d/rc.local里加入(如果没有执行权限，需要chmod +x rc.local) 12/bin/systemctl start crond.service 或/bin/systemctl start crond.service （Centos7推荐） 创建定时任务 执行命令 1crontab -e 创建定时任务vi 命令执行插入每小时的15分钟 定时执行更新时间命令 115 * * * * ntpdate 202.112.31.197 查看定时任务 1crontab -l 删除定时任务 1crontab -r cron相关命令1234/sbin/service crond start #启动/sbin/service crond stop #停止/sbin/service crond restart #重启/sbin/service crond reload #重载 crontab的相关命令123crontab -e #编辑任务crontab -l #查看当前用户的任务crontab -l -u root #查看指定用户的任务 定时任务编写的基本格式12345678* * * * * command分 时 日 月 周 命令第1列表示分钟1～59 每分钟用*或者 */1表示第2列表示小时1～23（0表示0点）第3列表示日期1～31第4列表示月份1～12第5列标识号星期0～6（0表示星期天）第6列要运行的命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>定时任务</tag>
        <tag>更新时间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频压缩ffmpeg]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%A7%86%E9%A2%91%E5%8E%8B%E7%BC%A9ffmpeg%2F</url>
    <content type="text"><![CDATA[受够了网上那些所谓的免费压缩。还是自己动手吧。 下载地址：http://ffmpeg.org/download.html 解压路径添加到path视频压缩命令 微信不允许传输超过25兆的视频，在这里设置分辨率800X4001ffmpeg -y -i video.mp4 -ss 00:00:00.0 -t 00:06:00.0 -ab 56k -ar 44100 -b:v 2200k -r 29.97 -s 480x800 out.mp4 参数说明 通用选项 123456789101112131415-L license-h 帮助-fromats 显示可用的格式，编解码的，协议的...-f fmt 强迫采用格式fmt-I filename 输入文件-y 覆盖输出文件-t duration 设置纪录时间 hh:mm:ss[.xxx]格式的记录时间也支持-ss position 搜索到指定的时间 [-]hh:mm:ss[.xxx]的格式也支持-title string 设置标题-author string 设置作者-copyright string 设置版权-comment string 设置评论-target type 设置目标文件类型(vcd,svcd,dvd) 所有的格式选项（比特率，编解码以及缓冲区大小）自动设置，只需要输入如下的就可以了：ffmpeg -i myfile.avi -target vcd /tmp/vcd.mpg-hq 激活高质量设置-itsoffset offset 设置以秒为基准的时间偏移，该选项影响所有后面的输入文件。该偏移被加到输入文件的时戳，定义一个正偏移意味着相应的流被延迟了 offset秒。 [-]hh:mm:ss[.xxx]的格式也支持 视频选项 123456789101112131415161718-b bitrate 设置比特率，缺省200kb/s-r fps 设置帧频 缺省25-s size 设置帧大小 格式为WXH 缺省160X128.下面的简写也可以直接使用：Sqcif 128X96 qcif 176X144 cif 252X288 4cif 704X576-aspect aspect 设置横纵比 4:3 16:9 或 1.3333 1.7777-croptop size 设置顶部切除带大小 像素单位-cropbottom size –cropleft size –cropright size-padtop size 设置顶部补齐的大小 像素单位-padbottom size –padleft size –padright size –padcolor color 设置补齐条颜色(hex,6个16进制的数，红:绿:兰排列，比如 000000代表黑色)-vn 不做视频记录-bt tolerance 设置视频码率容忍度kbit/s-maxrate bitrate设置最大视频码率容忍度-minrate bitreate 设置最小视频码率容忍度-bufsize size 设置码率控制缓冲区大小-vcodec codec 强制使用codec编解码方式。如果用copy表示原始编解码数据必须被拷贝。-sameq 使用同样视频质量作为源（VBR）-pass n 选择处理遍数（1或者2）。两遍编码非常有用。第一遍生成统计信息，第二遍生成精确的请求的码率-passlogfile file 选择两遍的纪录文件名为file 高级视频选项 123456789101112131415161718192021222324252627282930313233-g gop_size 设置图像组大小-intra 仅适用帧内编码-qscale q 使用固定的视频量化标度(VBR)-qmin q 最小视频量化标度(VBR)-qmax q 最大视频量化标度(VBR)-qdiff q 量化标度间最大偏差 (VBR)-qblur blur 视频量化标度柔化(VBR)-qcomp compression 视频量化标度压缩(VBR)-rc_init_cplx complexity 一遍编码的初始复杂度-b_qfactor factor 在p和b帧间的qp因子-i_qfactor factor 在p和i帧间的qp因子-b_qoffset offset 在p和b帧间的qp偏差-i_qoffset offset 在p和i帧间的qp偏差-rc_eq equation 设置码率控制方程 默认tex^qComp-rc_override override 特定间隔下的速率控制重载-me method 设置运动估计的方法 可用方法有 zero phods log x1 epzs(缺省) full-dct_algo algo 设置dct的算法 可用的有 0 FF_DCT_AUTO 缺省的DCT 1 FF_DCT_FASTINT 2 FF_DCT_INT 3 FF_DCT_MMX 4 FF_DCT_MLIB 5 FF_DCT_ALTIVEC-idct_algo algo 设置idct算法。可用的有 0 FF_IDCT_AUTO 缺省的IDCT 1 FF_IDCT_INT 2 FF_IDCT_SIMPLE 3 FF_IDCT_SIMPLEMMX 4 FF_IDCT_LIBMPEG2MMX 5 FF_IDCT_PS2 6 FF_IDCT_MLIB 7 FF_IDCT_ARM 8 FF_IDCT_ALTIVEC 9 FF_IDCT_SH4 10 FF_IDCT_SIMPLEARM-er n 设置错误残留为n 1 FF_ER_CAREFULL 缺省 2 FF_ER_COMPLIANT 3 FF_ER_AGGRESSIVE 4 FF_ER_VERY_AGGRESSIVE-ec bit_mask 设置错误掩蔽为bit_mask,该值为如下值的位掩码 1 FF_EC_GUESS_MVS (default=enabled) 2 FF_EC_DEBLOCK (default=enabled)-bf frames 使用frames B 帧，支持mpeg1,mpeg2,mpeg4-mbd mode 宏块决策 0 FF_MB_DECISION_SIMPLE 使用mb_cmp 1 FF_MB_DECISION_BITS 2 FF_MB_DECISION_RD-4mv 使用4个运动矢量 仅用于mpeg4-part 使用数据划分 仅用于mpeg4-bug param 绕过没有被自动监测到编码器的问题-strict strictness 跟标准的严格性-aic 使能高级帧内编码 h263+-umv 使能无限运动矢量 h263+-deinterlace 不采用交织方法-interlace 强迫交织法编码仅对mpeg2和mpeg4有效。当你的输入是交织的并且你想要保持交织以最小图像损失的时候采用该选项。可选的方法是不交织，但是损失更大-psnr 计算压缩帧的psnr-vstats 输出视频编码统计到vstats_hhmmss.log-vhook module 插入视频处理模块 module 包括了模块名和参数，用空格分开 音频选项 12345-ab bitrate 设置音频码率-ar freq 设置音频采样率-ac channels 设置通道 缺省为1-an 不使能音频纪录-acodec codec 使用codec编解码 音频/视频捕获选项 12345-vd device 设置视频捕获设备。比如/dev/video0-vc channel 设置视频捕获通道 DV1394专用-tvstd standard 设置电视标准 NTSC PAL(SECAM)-dv1394 设置DV1394捕获-av device 设置音频设备 比如/dev/dsp 高级选项 12345678-map file:stream 设置输入流映射-debug 打印特定调试信息-benchmark 为基准测试加入时间-hex 倾倒每一个输入包-bitexact 仅使用位精确算法 用于编解码测试-ps size 设置包大小，以bits为单位-re 以本地帧频读数据，主要用于模拟捕获设备-loop 循环输入流（只工作于图像流，用于ffserver测试） 具体查文档]]></content>
      <tags>
        <tag>视频</tag>
        <tag>ffmpeg</tag>
        <tag>moviepy</tag>
        <tag>小记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[财务信息中心服务号分析]]></title>
    <url>%2F2018%2F03%2F18%2F%E8%B4%A2%E5%8A%A1%E4%BF%A1%E6%81%AF%E4%B8%AD%E5%BF%83%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[从自身的需求出发，开发了本服务号方便员工获取、跟踪信息提供统一的记录地点 功能介绍 员工信息 工资查询 报销跟踪 智能助手 公司信息（比如发票） 员工信息 第一次关注时，需要填写员工信息并提交 查看员工个人信息 如果修改信息，需要通知管理员，将状态修改为可更新 工资查询查询类别 月收入（工资） 项目可（津贴） 年度统计 查询方式 点击推送 UI交互 输入交互 三种查询方式，可以更大程度上满足用户的查询需求，并更大程度上保障了在网络不好时的一个查询结果，比如：输入交互通常比UI交互快一些 发票信息 大家在群里沟通时，提到发票信息不能以一种友好的方式进行查询、保存 点击推送，图文格式的发票信息—美观 一张图片，无法编辑 输入”发票”，文本格式的发票信息—不美观 可以进行复制、编辑 迎合不同宾馆填写发票多种方式的需求，比如：有的宾馆需要用户通过微信去填写 报销跟踪 工作生活中，发现不能很好地跟踪报销的进度、核实对比报销金额 创建报销 选择不同的出差类别 跟出差类别，自动计算出差补贴 报销记录 显示已填写未处理的所有报销 工资卡收到到款提醒时，比对金额无误时，点击处理，该报销记录完成（该记录消失） 财务发放报销后，会通过公众号将数据推送到员工，员工收到信息后。再比对报销记录。 报销跟踪，需要员工个人进行维护 智能助手 提供一些辅助功能 天气、翻译、计算器、菜谱 百科、故事、笑话、运势]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>服务号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown与极简图床]]></title>
    <url>%2F2018%2F03%2F18%2FMarkDown%E4%B8%8E%E6%9E%81%E7%AE%80%E5%9B%BE%E5%BA%8A%2F</url>
    <content type="text"><![CDATA[安装极简图床可以同谷歌store下载，也可以手动安装 选择图床图床包括三种： 阿里云OOS 七牛云 新浪微博 作者在这里选用的阿里云和新浪微博，当然新浪微博是免费的（不能保证后期会不会禁掉这个功能），在这里推荐使用阿里云（收费）。 新浪微博这个最简单，只需要在网页上登录下微博即可，本质应该是通过爬虫的方式集成的接口，以后有可能被封。 七牛云免费流量0-10G，超出不会自动停。 阿里云OOS据说前几年推广时，有50G免费，现在貌似没有了。作者在这里先买了一年40G的套餐。 登录阿里云开通对象存储OOS建 Bucket，按要求输入 Bucket 名称，选择好区域后记录下 Endpoint 备用，读写权限选择“公共读” 在控制台右上角选择 accesskyes，选择“继续使用AccessKey” 点击 “创建 Access Key”，创建完成后记录下 Access Key ID 和 Key Secret 备用 回到极简图床网站，点击右上角进行设置，选择阿里云 OSS 选项卡，按要求填写 Bucket、Endpoint（第一步创建时所得），Access Key ID 以及 Key Secret （上面第三步中获取），完成后保存，就可以将图片存储到你的阿里云 OSS 上了。 使用极简图床获取MarkDown需要的图片地址 复制到文章里即可]]></content>
      <categories>
        <category>基础设施</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>极简图床</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公众号发布文章]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%85%AC%E4%BC%97%E5%8F%B7%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[登录公众号后台创建素材管理–素材管理，点击新建图文素材 使用秀米编辑器进行排版 登录后，添加新的图文 选择模板，进行排版，并复制 复制到刚建的图文素材CTRL+V即可复制到新建图文 稍作修改，添加封面，保存 推送文章 进入页面模板 创建模板，添加素材 发布]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>排版</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[itchatmp安装报future的error]]></title>
    <url>%2F2018%2F03%2F18%2Fitchatmp%E5%AE%89%E8%A3%85%E6%8A%A5future%E7%9A%84error%2F</url>
    <content type="text"><![CDATA[itchatmp安装时报future无法在python3上安装最新版的future不支持python3运行 解决方法指定future版本为3.1.11pip3 install futures==3.1.1；pip3 install itchatmp]]></content>
      <categories>
        <category>公众号</category>
      </categories>
      <tags>
        <tag>公众号</tag>
        <tag>itchatmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm远程调试]]></title>
    <url>%2F2018%2F03%2F18%2FPycharm%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[配置远程环境 配置SFTP进行代码同步 配置自动同步CRTL+S 远程SSH控制台 比较代码差异Brower Remote Host可以直接查看远程服务器的代码比较本地开发目录与远程指定目录的代码差异 切换历史远程环境]]></content>
      <categories>
        <category>基础设施</category>
      </categories>
      <tags>
        <tag>开发工具</tag>
        <tag>pycharm</tag>
        <tag>远程调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[T470拆机]]></title>
    <url>%2F2018%2F03%2F18%2FT470%E6%8B%86%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[拆硬盘 注意这个硬盘是要拽住那个揪揪，晃晃整个就起来了 那个跟硬盘对口的接口是可活动的（一根线，小心别拽断了）（不需要拆喇叭） 拆机时注意，去卡扣时，是电脑反着，先从左右两面或下面开始，先用手指挤开，再卡片推过去（电脑盖朝下）（不要从电池那面开）。 进入Bios 开机按F1（不按FN） 设置U盘启动时注意，按F9重置后，手动选下面的保存。不要按F10保存（否则会开机恢复原来的设置） U盘启动：开机后按F12（不需要FN） WinPE版本 Cpu7系列只允许装win10，因此WINPE也只能用win10核心的 PE使用WEPE 操作系统-win10VL版本 VL版本的系统允许通过KMS方式激活 系统下载在MSDN上下载 小新i2000拆机 显示屏所在面在下面，就是反放 从usb口开始，用银行卡慢慢刷]]></content>
      <categories>
        <category>硬件</category>
      </categories>
      <tags>
        <tag>拆机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pycharm开发Micropython]]></title>
    <url>%2F2018%2F03%2F17%2FPycharm%E5%BC%80%E5%8F%91Micropython%2F</url>
    <content type="text"><![CDATA[安装插件micropython 配置代码提示 配好后会提示mpy的语法 把代码转换为mpy代码 pycharm无法进程mpy的远程调试，只能将代码直接传进开发板 备注 hexo的图片路径：/images/xxx.png]]></content>
      <categories>
        <category>基础设施</category>
      </categories>
      <tags>
        <tag>pycharm</tag>
        <tag>micropython</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2018%2F03%2F17%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。无序列表 列表1 列表2 列表3 有序列表 列表1 列表2 列表3 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样 只需要在文本前加入 &gt; 这种尖括号（大于号）即可 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。 例如：这里是粗体这里是斜体 表格表格是我觉得 Markdown 比较累人的地方，例子如下： 这种语法生成的表格如下： 参数名 类型 说明 args1 string 参数1 args2 [] 参数2 args3 string 参数3 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用三个 把中间的代码包裹起来，如code`。 1234 &#123; &apos;result&apos;: &apos;error&apos;, &apos;reason&apos;:&apos;xxx&apos;&#125; 使用 tab 键即可缩进。 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可。]]></content>
  </entry>
  <entry>
    <title><![CDATA[什么是跨域]]></title>
    <url>%2F2018%2F03%2F17%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域的含义跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。 所谓同源是指，域名，协议，端口均相同。 如何解决跨域问题 JSONP（不推荐）只支持GET，不支持POST 代理通过Nginx进行反向代理。相当于绕过了浏览器端，自然就不存在跨域问题。 XHR2的方式后端返回数据给前端时，添加header：12header(&apos;Access-Control-Allow-Origin:*&apos;);//允许所有来源访问header(&apos;Access-Control-Allow-Method:POST,GET&apos;);//允许访问的方式]]></content>
      <categories>
        <category>网络基础</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人总结]]></title>
    <url>%2F2018%2F03%2F17%2F%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[硬件服务器、单片机、树莓派、安卓机 操作系统CentOS7、Debian9、Ubuntu17、Windows 开发语言Python、Java、MicroPython、JavaScript、Lua、Go 前端框架Vue、Bootstrap、ElementUI、WeUI WEB框架Flask、Django、Tornado、NameKO、Spring、Odoo 数据库Mysql、Redis、Oracle、Sqlite、MongoDB、PostgreSQL 数据挖掘Pandas、Keras、Sklearn、Tensorflow 开发能力智能家居网关系统 Web自动化/压力测试/开发 App自动化/测试/开发 Gui自动化/测试/开发 物联网开发 公众号开发 微信机器人开发 网络爬虫 机器学习（图片处理） 存档部署运维GIT存档、Docker（Rancher）、新浪SAE、内网穿透、VPN、Supervisor 项目记录论文总结性格温和、友善，乐于交流、分享、学习； 软硬件均有涉猎，喜欢学习新知识，入手新领域较快； 阶段2015年，基础 2016年，入门 2017年，扩展 2018年，沉淀]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码可读性]]></title>
    <url>%2F2018%2F03%2F16%2F%E4%BB%A3%E7%A0%81%E5%8F%AF%E8%AF%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[可读性的重要性 用名字表达代码含义 名字不能带来歧义 良好的代码风格 编写注释 如何编写注释 提高控制流的可读性 拆分长表达式 变量与可读性 抽取函数 一次只做一件事 用自然语言表述代码 减少代码量 可读性的重要性编程有很大一部分时间是在阅读代码，不仅要阅读自己的代码，而且要阅读别人的代码。因此，可读性良好的代码能够大大提高编程效率。 可读性良好的代码往往会让代码架构更好，因为程序员更愿意去修改这部分代码，而且也更容易修改。 只有在核心领域为了效率才可以放弃可读性，否则可读性是第一位。 用名字表达代码含义一些比较有表达力的单词： 单词 可替代单词 send deliver、dispatch、announce、distribute、route find search、extract、locate、recover start launch、create、begin、open make create、set up、build、generate、compose、add、new 使用 i、j、k 作为循环迭代器的名字过于简单，user_i、member_i 这种名字会更有表达力。因为循环层次越多，代码越难理解，有表达力的迭代器名字可读性会更高 为名字添加形容词等信息能让名字更具有表达力，但是名字也会变长。名字长短的准则是：作用域越大，名字越长。因此只有在短作用域才能使用一些简单名字。 名字不能带来歧义起完名字要思考一下别人会对这个名字有何解读，会不会误解了原本想表达的含义。 用 min、max 表示数量范围；用 first、last 表示访问空间的包含范围，begin、end 表示访问空间的排除范围，即 end 不包含尾部。 布尔相关的命名加上 is、can、should、has 等前缀。 良好的代码风格适当的空行和缩进。 排列整齐的注释： 123int a = 1; // 注释int b = 11; // 注释int c = 111; // 注释 语句顺序不能随意，比如与 html 表单相关联的变量的赋值应该和表单在 html 中的顺序一致； 把相关的代码按块组织起来放在一起。 编写注释阅读代码首先会注意到注释，如果注释没太大作用，那么就会浪费代码阅读的时间。那些能直接看出含义的代码不需要写注释，特别是并不需要为每个方法都加上注释，比如那些简单的 getter 和 setter 方法，为这些方法写注释反而让代码可读性更差。 不能因为有注释就随便起个名字，而是争取起个好名字而不写注释。 可以用注释来记录采用当前解决办法的思考过程，从而让读者更容易理解代码。 注释用来提醒一些特殊情况。 用 TODO 等做标记： 标记 用法 TODO 待做 FIXME 待修复 HACH 粗糙的解决方案 XXX 危险！这里有重要的问题 如何编写注释尽量简洁明了： 123// The first String is student&apos;s name// The Second Integer is student&apos;s scoreMap&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); 12// Student&apos; name -&gt; Student&apos;s scoreMap&lt;String, Integer&gt; scoreMap = new HashMap&lt;&gt;(); 添加测试用例来说明： 12345//...// Example: add(1, 2), return 3int add(int x, int y) &#123; return x + y;&#125; 在很复杂的函数调用中对每个参数标上名字： 123int a = 1;int b = 2;int num = add(\* x = *\ a, \* y = *\ b); 使用专业名词来缩短概念上的解释，比如用设计模式名来说明代码。 提高控制流的可读性条件表达式中，左侧是变量，右侧是常数。比如下面第一个语句正确： 12if(len &lt; 10)if(10 &gt; len) if / else 条件语句，逻辑的处理顺序为：① 正逻辑；② 关键逻辑；③ 简单逻辑。12345if(a == b) &#123; // 正逻辑&#125; else&#123; // 反逻辑&#125; 只有在逻辑简单的情况下使用 ? : 三目运算符来使代码更紧凑，否则应该拆分成 if / else； do / while 的条件放在后面，不够简单明了，并且会有一些迷惑的地方，最好使用 while 来代替。 如果只有一个 goto 目标，那么 goto 尚且还能接受，但是过于复杂的 goto 会让代码可读性特别差，应该避免使用 goto。 在嵌套的循环中，用一些 return 语句往往能减少嵌套的层数。 拆分长表达式长表达式的可读性很差，可以引入一些解释变量从而拆分表达式： 12if line.split(&apos;:&apos;)[0].strip() == &quot;root&quot;: ... 123username = line.split(&apos;:&apos;)[0].strip()if username == &quot;root&quot;: ... 使用摩根定理简化一些逻辑表达式： 123if(!a &amp;&amp; !b) &#123; ...&#125; 123if(a || b) &#123; ...&#125; 变量与可读性去除控制流变量 。在循环中通过使用 break 或者 return 可以减少控制流变量的使用。 12345678boolean done = false;while(/* condition */ &amp;&amp; !done) &#123; ... if(...) &#123; done = true; continue; &#125;&#125; 123456while(/* condition */) &#123; ... if(...) &#123; break; &#125;&#125; 减小变量作用域 。作用域越小，越容易定位到变量所有使用的地方。 JavaScript 可以用闭包减小作用域。以下代码中 submit_form 是函数变量，submitted 变量控制函数不会被提交两次。第一个实现中 submitted 是全局变量，第二个实现把 submitted 放到匿名函数中，从而限制了起作用域范围。 1234567submitted = false;var submit_form = function(form_name) &#123; if(submitted) &#123; return; &#125; submitted = true;&#125;; 123456789var submit_form = (function() &#123; var submitted = false; return function(form_name) &#123; if(submitted) &#123; return; &#125; submitted = true; &#125;&#125;()); // () 使得外层匿名函数立即执行 JavaScript 中没有用 var 声明的变量都是全局变量，而全局变量很容易造成迷惑，因此应当总是用 var 来声明变量。 变量定义的位置应当离它使用的位置最近。 实例解析 在一个网页中有以下文本输入字段： 1234&lt;input type = &quot;text&quot; id = &quot;input1&quot; value = &quot;a&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input2&quot; value = &quot;b&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input3&quot; value = &quot;&quot;&gt;&lt;input type = &quot;text&quot; id = &quot;input4&quot; value = &quot;d&quot;&gt; 现在要接受一个字符串并把它放到第一个空的 input 字段中，初始实现如下： 123456789101112131415var setFirstEmptyInput = function(new_alue) &#123; var found = false; var i = 1; var elem = document.getElementById(&apos;input&apos; + i); while(elem != null) &#123; if(elem.value === &apos;&apos;) &#123; found = true; break; &#125; i++; elem = document.getElementById(&apos;input&apos; + i); &#125; if(found) elem.value = new_value; return elem;&#125; 以上实现有以下问题： found 可以去除； elem 作用域过大； 可以用 for 循环代替 while 循环； 123456789101112var setFirstEmptyInput = function(new_value) &#123; for(var i = 1; true; i++) &#123; var elem = document.getElementById(&apos;input&apos; + i); if(elem === null) &#123; return null; &#125; if(elem.value === &apos;&apos;) &#123; elem.value = new_value; return elem; &#125; &#125;&#125;; 抽取函数工程学就是把大问题拆分成小问题再把这些问题的解决方案放回一起。 首先应该明确一个函数的高层次目标，然后对于不是直接为了这个目标工作的代码，抽取出来放到独立的函数中。 介绍性的代码： 12345678910111213141516int findClostElement(int[] arr) &#123; int clostIdx; int clostDist = Interger.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++) &#123; int x = ...; int y = ...; int z = ...; int value = x * y * z; int dist = Math.sqrt(Math.pow(value, 2), Math.pow(arr[i], 2)); if(dist &lt; clostDist) &#123; clostIdx = i; clostDist = value; &#125; &#125; return clostIdx;&#125; 以上代码中循环部分主要计算距离，这部分不属于代码高层次目标，高层次目标是寻找最小距离的值，因此可以把这部分代替提取到独立的函数中。这样做也带来一个额外的好处有：可以单独进行测试、可以快速找到程序错误并修改。 123456789101112public int findClostElement(int[] arr) &#123; int clostIdx; int clostDist = Interger.MAX_VALUE; for(int i = 0; i &lt; arr.length; i++) &#123; int dist = computDist(arr, i); if(dist &lt; clostDist) &#123; clostIdx = i; clostDist = value; &#125; &#125; return clostIdx;&#125; 并不是函数抽取的越多越好，如果抽取过多，在阅读代码的时候可能需要不断跳来跳去。只有在当前函数不需要去了解某一块代码细节而能够表达其内容时，把这块代码抽取成子函数才是好的。 函数抽取也用于减小代码的冗余。 一次只做一件事只做一件事的代码很容易让人知道其要做的事； 基本流程：列出代码所做的所有任务；把每个任务拆分到不同的函数，或者不同的段落。 用自然语言表述代码先用自然语言书写代码逻辑，也就是伪代码，然后再写代码，这样代码逻辑会更清晰。 减少代码量不要过度设计，编码过程会有很多变化，过度设计的内容到最后往往是无用的。 多用标准库实现。 参考资料 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT]]></title>
    <url>%2F2018%2F03%2F16%2FGIT%2F</url>
    <content type="text"><![CDATA[学习资料 集中式与分布式 Git 的中心服务器 Git 工作流 分支实现 冲突 Fast forward 分支管理策略 储藏（Stashing） SSH 传输设置 .gitignore 文件 Git 命令一览 学习资料 Git - 简明指南 图解 Git 廖雪峰 : Git 教程 Learn Git Branching 集中式与分布式Git 属于分布式版本控制系统，而 SVN 属于集中式。 集中式版本控制只有中心服务器拥有一份代码，而分布式版本控制每个人的电脑上就有一份完整的代码。 集中式版本控制有安全性问题，当中心服务器挂了所有人都没办法工作了。 集中式版本控制需要连网才能工作，如果网速过慢，那么提交一个文件的会慢的无法让人忍受。而分布式版本控制不需要连网就能工作。 分布式版本控制新建分支、合并分支操作速度非常快，而集中式版本控制新建一个分支相当于复制一份完整代码。 Git 的中心服务器Git 的中心服务器用来交换每个用户的修改。没有中心服务器也能工作，但是中心服务器能够 24 小时保持开机状态，这样就能更方便的交换修改。Github 就是一种 Git 中心服务器。 Git 工作流新建一个仓库之后，当前目录就成为了工作区，工作区下有一个隐藏目录 .git，它属于 Git 的版本库。 Git 版本库有一个称为 stage 的暂存区，还有自动创建的 master 分支以及指向分支的 HEAD 指针。 git add files 把文件的修改添加到暂存区 git commit 把暂存区的修改提交到当前分支，提交之后暂存区就被清空了 git reset – files 使用当前分支上的修改覆盖暂缓区，用来撤销最后一次 git add files git checkout – files 使用暂存区的修改覆盖工作目录，用来撤销本地修改 可以跳过暂存区域直接从分支中取出修改或者直接提交修改到分支中 git commit -a 直接把所有文件的修改添加到暂缓区然后执行提交 git checkout HEAD – files 取出最后一次修改，可以用来进行回滚操作 分支实现Git 把每次提交都连成一条时间线。分支使用指针来实现，例如 master 分支指针指向时间线的最后一个节点，也就是最后一次提交。HEAD 指针指向的是当前分支。 新建分支是新建一个指针指向时间线的最后一个节点，并让 HEAD 指针指向新分支表示新分支成为当前分支。 每次提交只会让当前分支向前移动，而其它分支不会移动。 合并分支也只需要改变指针即可。 冲突当两个分支都对同一个文件进行了修改，在分支合并时就会产生冲突。 Git 会使用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ，======= ，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记出不同分支的内容，只需要把不同分支中冲突部分修改成一样就能解决冲突。 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 Fast forward“快进式合并”（fast-farward merge），会直接将 master 分支指向合并的分支，这种模式下进行分支合并会丢失分支信息，也就不能在分支历史上看出分支信息。 可以在合并时加上 –no-ff 参数来禁用 Fast forward 模式，并且加上 -m 参数让合并时产生一个新的 commit。 1$ git merge --no-ff -m &quot;merge with no-ff&quot; dev 分支管理策略master 分支应该是非常稳定的，只用来发布新版本； 日常开发在开发分支 dev 上进行。 储藏（Stashing）在一个分支上操作之后，如果还没有将修改提交到分支上，此时进行切换分支，那么另一个分支上也能看到新的修改。这是因为所有分支都共用一个工作区的缘故。 可以使用 git stash 将当前分支的修改储藏起来，此时当前工作区的所有修改都会被存到栈上，也就是说当前工作区是干净的，没有任何未提交的修改。此时就可以安全的切换到其它分支上了。 123$ git stashSaved working directory and index state \ &quot;WIP on master: 049d078 added the index file&quot;HEAD is now at 049d078 added the index file (To restore them type &quot;git stash apply&quot;) 该功能可以用于 bug 分支的实现。如果当前正在 dev 分支上进行开发，但是此时 master 上有个 bug 需要修复，但是 dev 分支上的开发还未完成，不想立即提交。在新建 bug 分支并切换到 bug 分支之前就需要使用 git stash 将 dev 分支的未提交修改储藏起来。 SSH 传输设置Git 仓库和 Github 中心仓库之间是通过 SSH 加密。 如果工作区下没有 .ssh 目录，或者该目录下没有 id_rsa 和 id_rsa.pub 这两个文件，可以通过以下命令来创建 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 然后把公钥 id_rsa.pub 的内容复制到 Github “Account settings” 的 SSH Keys 中。 .gitignore 文件忽略以下文件： 操作系统自动生成的文件，比如缩略图； 编译生成的中间文件，比如 Java 编译产生的 .class 文件； 自己的敏感信息，比如存放口令的配置文件。 不需要全部自己编写，可以到 https://github.com/github/gitignore 中进行查询。 Git 命令一览比较详细的地址：http://www.cheat-sheets.org/saved-copy/git-cheat-sheet.pdf 参考资料 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL]]></title>
    <url>%2F2018%2F03%2F16%2FMYSQL%2F</url>
    <content type="text"><![CDATA[存储引擎 1. InnoDB 2. MyISAM 3. InnoDB 与 MyISAM 的比较 数据类型 1. 整型 2. 浮点数 3. 字符串 4. 时间和日期 索引 1. 索引分类 1.1 B-Tree 索引 1.2 哈希索引 1.3. 空间索引（R-Tree） 1.4 全文索引 2. 索引的优点 3. 索引优化 3.1 独立的列 3.2 前缀索引 3.3 多列索引 3.4 索引列的顺序 3.5 聚簇索引 3.6 覆盖索引 4. B-Tree 和 B+Tree 原理 4. 1 B-Tree 4.2 B+Tree 4.3 带有顺序访问指针的 B+Tree 4.4 为什么使用 B-Tree 和 B+Tree 查询性能优化 1. Explain 2. 减少返回的列 3. 减少返回的行 4. 拆分大的 DELETE 或 INSERT 语句 分库与分表 1. 分库与分表的原因 2. 实现方式 2.1 垂直切分 2.2 水平切分 2.3 切分的选择 3. Merge 存储引擎 4. 分库与分表存在的问题 4.1 事务问题 4.2 跨库跨表连接问题 4.3 额外的数据管理负担和数据运算压力 5. 分表与分区的不同 故障转移和故障恢复 参考资料 存储引擎1. InnoDBInnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别，默认级别是可重复读。 表是基于聚簇索引建立的，它对主键的查询性能有很高的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引、能够加速插入操作的插入缓冲区等。 通过一些机制和工具支持真正的热备份。 2. MyISAMMyISAM 提供了大量的特性，包括全文索引、压缩、空间函数（GIS）等。但 MyISAM 不支持事务和行级锁，而且崩溃后无法安全恢复。 只能对整张表加锁，而不是针对行。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 可以包含动态或者静态的行。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表适合采用 MyISAM 压缩表。 对于只读数据，或者表比较小、可以容忍修复操作，则依然可以继续使用 MyISAM。 MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。 3. InnoDB 与 MyISAM 的比较事务 InnoDB 是事务型的。 备份 InnoDB 支持在线热备份。 崩溃恢复 MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 并发 MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 其它特性 MyISAM 支持全文索引，地理空间索引。 数据类型1. 整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 2. 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 3. 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 4. 时间和日期MySQL 提供了两种相似的日期时间类型：DATATIME 和 TIMESTAMP。 DATATIME 能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATATIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 TIMESTAMP 和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。 它和时区有关。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 索引能够轻易将查询性能提升几个数量级。 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效。对于中到大型的表，索引就非常有效。但是对于特大型的表，建立和使用索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 1. 索引分类1.1 B-Tree 索引B-Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。 可以指定多个列作为索引列，多个索引列共同组成键。B-Tree 索引适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。 除了用于查找，还可以用于排序和分组。 如果不是按照索引列的顺序进行查找，则无法使用索引。 1.2 哈希索引基于哈希表实现，优点是查找非常快。 在 MySQL 中只有 Memory 引擎显式支持哈希索引。 InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B-Tree 索引之上再创建一个哈希索引，这样就让 B-Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 限制：哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响并不明显；无法用于分组与排序；只支持精确查找，无法用于部分查找和范围查找；如果哈希冲突很多，查找速度会变得很慢。 1.3. 空间索引（R-Tree）MyISAM 存储引擎支持空间索引，可以用于地理数据存储。 空间索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 1.4 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较索引中的值。 使用 MATCH AGAINST，而不是普通的 WHERE。 2. 索引的优点 大大减少了服务器需要扫描的数据量； 帮助服务器避免进行排序和创建临时表； 将随机 I/O 变为顺序 I/O。 3. 索引优化3.1 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 3.2 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据 索引选择性 来确定：不重复的索引值和记录总数的比值。选择性越高，查询效率也越高。最大值为 1 ，此时每个记录都有唯一的索引与其对应。 3.3 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWhERE actor_id = 1 AND film_id = 1; 3.4 索引列的顺序让选择性最强的索引列放在前面，例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 3.5 聚簇索引聚簇索引并不是一种索引类型，而是一种数据存储方式。 术语“聚簇”表示数据行和相邻的键值紧密地存储在一起，InnoDB 的聚簇索引的数据行存放在 B-Tree 的叶子页中。 因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 优点 可以把相关数据保存在一起，减少 I/O 操作； 因为数据保存在 B-Tree 中，因此数据访问更快。 缺点 聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引。 插入速度严重依赖于插入顺序，按主键的顺序插入是最快的。 更新操作代价很高，因为每个被更新的行都会移动到新的位置。 当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间。 如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢。 3.6 覆盖索引索引包含所有需要查询的字段的值。 优点 因为索引条目通常远小于数据行的大小，所以若只读取索引，能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若二级索引能够覆盖查询，则无需访问聚簇索引。 4. B-Tree 和 B+Tree 原理4. 1 B-Tree为了描述 B-Tree，首先定义一条数据记录为一个二元组 [key, data]，key 为记录的键，data 为数据记录除 key 外的数据。 B-Tree 是满足下列条件的数据结构： 所有叶节点具有相同的深度，也就是说 B-Tree 是平衡的； 一个节点中的 key 从左到右非递减排列； 如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于 keyi 且小于 keyi+1。 在 B-Tree 中按 key 检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的 data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到 null 指针，前者查找成功，后者查找失败。 由于插入删除新的数据记录会破坏 B-Tree 的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持 B-Tree 性质。 4.2 B+Tree与 B-Tree 相比，B+Tree 有以下不同点： 每个节点的指针上限为 2d 而不是 2d+1； 内节点不存储 data，只存储 key，叶子节点不存储指针。 4.3 带有顺序访问指针的 B+Tree一般在数据库系统或文件系统中使用的 B+Tree 结构都在经典 B+Tree 基础上进行了优化，在叶子节点增加了顺序访问指针，做这个优化的目的是为了提高区间访问的性能。 4.4 为什么使用 B-Tree 和 B+Tree红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用 B-/+Tree 作为索引结构。 页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为 4k），主存和磁盘以页为单位交换数据。 一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次 I/O 就可以完全载入。B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为 O(h)=O(logdN)。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过 3）。而红黑树这种结构，h 明显要深的多。并且于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，效率明显比 B-Tree 差很多。 B+Tree 更适合外存索引，原因和内节点出度 d 有关。由于 B+Tree 内节点去掉了 data 域，因此可以拥有更大的出度，拥有更好的性能。 查询性能优化1. Explain用来分析 SQL 语句，分析结果中比较重要的字段有： select_type : 查询类型，有简单查询、联合查询和子查询 key : 使用的索引 rows : 扫描的行数 2. 减少返回的列慢查询主要是因为访问了过多数据，除了访问过多行之外，也包括访问过多列。 最好不要使用 SELECT * 语句，要根据需要选择查询的列。 3. 减少返回的行最好使用 LIMIT 语句来取出想要的那些行。 还可以建立索引来减少条件语句的全表扫描。例如对于下面的语句，不使用索引的情况下需要进行全表扫描，而使用索引只需要扫描几行记录即可，使用 Explain 语句可以通过观察 rows 字段来看出这种差异。 1SELECT * FROM sakila.film_actor WHERE film_id = 1; 4. 拆分大的 DELETE 或 INSERT 语句如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( "DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000")&#125; while rows_affected &gt; 0 分库与分表1. 分库与分表的原因随着时间和业务的发展，数据库中的表会越来越多，并且表中的数据量也会越来越大，那么读写操作的开销也会随着增大。 2. 实现方式2.1 垂直切分将表按功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立商品数据库 payDB、用户数据库 userDB 等，分别用来存储项目与商品有关的表和与用户有关的表。 2.2 水平切分把表中的数据按照某种规则存储到多个结构相同的表中，例如按 id 的散列值、性别等进行划分。 2.3 切分的选择如果数据库中的表太多，并且项目各项业务逻辑清晰，那么垂直切分是首选。 如果数据库的表不多，但是单表的数据量很大，应该选择水平切分。 3. Merge 存储引擎该存储引擎支持分表。 4. 分库与分表存在的问题4.1 事务问题在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。 4.2 跨库跨表连接问题在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上。这时，表的连接操作将受到限制，我们无法连接位于不同分库的表，也无法连接分表粒度不同的表，导致原本只需要一次查询就能够完成的业务需要进行多次才能完成。 4.3 额外的数据管理负担和数据运算压力最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算。 5. 分表与分区的不同分表，就是将一张表分成多个小表，这些小表拥有不同的表名；而分区是将一张表的数据分为多个区块，这些区块可以存储在同一个磁盘上，也可以存储在不同的磁盘上，这种方式下表仍然只有一个。 故障转移和故障恢复故障转移也叫做切换，当主库出现故障时就切换到备库，使备库成为主库。故障恢复顾名思义就是从故障中恢复过来，并且保证数据的正确性。 提升备库或切换角色 提升一台备库为主库，或者在一个主-主复制结构中调整主动和被动角色。 虚拟 IP 地址和 IP 托管 为 MySQL 实例指定一个逻辑 IP 地址，当 MySQL 实例失效时，可以将 IP 地址转移到另一台 MySQL 服务器上。 中间件解决方案 通过代理，可以路由流量到可以使用的服务器上。 在应用中处理故障转移 将故障转移整合到应用中可能导致应用变得太过笨拙。 参考资料 高性能 MySQL MySQL 索引背后的数据结构及算法原理 20+ 条 MySQL 性能优化的最佳经验 数据库为什么分库分表？mysql的分库分表方案 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[REDIS]]></title>
    <url>%2F2018%2F03%2F16%2FREDIS%2F</url>
    <content type="text"><![CDATA[Redis 是什么 Redis 的五种基本类型 STRING LIST SET HASH ZSET 键的过期时间 发布与订阅 事务 持久化 快照持久化 AOF 持久化 复制 从服务器连接主服务器的过程 主从链 处理故障 分片 事件 事件类型 事件的调度与执行 Redis 与 Memcached 的区别 Redis 适用场景 数据淘汰策略 一个简单的论坛系统分析 文章信息 点赞功能 对文章进行排序 参考资料 Redis 是什么Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。 五种类型数据类型为：字符串、列表、集合、有序集合、散列表。 Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。 Redis 的五种基本类型 数据类型 可以存储的值 操作 STRING 字符串、整数或者浮点数 对整个字符串或者字符串的其中一部分执行操作 对整数和浮点数执行自增或者自减操作 LIST 链表 从两端压入或者弹出元素 读取单个或者多个元素 进行修剪，只保留一个范围内的元素 SET 无序集合 添加、获取、移除单个元素 检查一个元素是否存在于集合中 计算交集、并集、差集 从集合里面随机获取元素 HASH 包含键值对的无序散列表 添加、获取、移除单个键值对 获取所有键值对 检查某个键是否存在 ZSET 有序集合 添加、获取、删除元素个元素 根据分值范围或者成员来获取元素 计算一个键的排名 What Redis data structures look like STRING12345678&gt; set hello worldOK&gt; get hello"world"&gt; del hello(integer) 1&gt; get hello(nil) LIST123456789101112131415161718192021&gt; rpush list-key item(integer) 1&gt; rpush list-key item2(integer) 2&gt; rpush list-key item(integer) 3&gt; lrange list-key 0 -11) "item"2) "item2"3) "item"&gt; lindex list-key 1"item2"&gt; lpop list-key"item"&gt; lrange list-key 0 -11) "item2"2) "item" SET123456789101112131415161718192021222324252627&gt; sadd set-key item(integer) 1&gt; sadd set-key item2(integer) 1&gt; sadd set-key item3(integer) 1&gt; sadd set-key item(integer) 0&gt; smembers set-key1) "item"2) "item2"3) "item3"&gt; sismember set-key item4(integer) 0&gt; sismember set-key item(integer) 1&gt; srem set-key item2(integer) 1&gt; srem set-key item2(integer) 0&gt; smembers set-key1) "item"2) "item3" HASH123456789101112131415161718192021222324&gt; hset hash-key sub-key1 value1(integer) 1&gt; hset hash-key sub-key2 value2(integer) 1&gt; hset hash-key sub-key1 value1(integer) 0&gt; hgetall hash-key1) "sub-key1"2) "value1"3) "sub-key2"4) "value2"&gt; hdel hash-key sub-key2(integer) 1&gt; hdel hash-key sub-key2(integer) 0&gt; hget hash-key sub-key1"value1"&gt; hgetall hash-key1) "sub-key1"2) "value1" ZSET12345678910111213141516171819202122232425&gt; zadd zset-key 728 member1(integer) 1&gt; zadd zset-key 982 member0(integer) 1&gt; zadd zset-key 982 member0(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member1"2) "728"3) "member0"4) "982"&gt; zrangebyscore zset-key 0 800 withscores1) "member1"2) "728"&gt; zrem zset-key member1(integer) 1&gt; zrem zset-key member1(integer) 0&gt; zrange zset-key 0 -1 withscores1) "member0"2) "982" 键的过期时间Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。 过期时间对于清理缓存数据非常有用。 发布与订阅发布与订阅实际上是观察者模式，订阅者订阅了频道之后，发布者向频道发送字符串消息会被所有订阅者接收到。 发布与订阅有一些问题，很少使用它，而是使用替代的解决方案。问题如下： 如果订阅者读取消息的速度很慢，会使得消息不断积压在发布者的输出缓存区中，造成内存占用过多； 如果订阅者在执行订阅的过程中网络出现问题，那么就会丢失断线期间发送的所有消息。 事务Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。 MULTI 和 EXEC 中的操作将会一次性发送给服务器，而不是一条一条发送，这种方式称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。 持久化Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。 快照持久化将某个时间点的所有数据都存放到硬盘上。 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。 如果系统发生故障，将会丢失最后一次创建快照之后的数据。并且如果数据量很大，保存快照的时间也会很长。 AOF 持久化AOF 持久化将写命令添加到 AOF 文件（Append Only File）的末尾。 对硬盘的文件进行写入时，写入的内容首先会被存储到缓冲区，然后由操作系统决定什么时候将该内容同步到硬盘，用户可以调用 file.flush() 方法请求操作系统尽快将缓冲区存储的数据同步到硬盘。因此将写命令添加到 AOF 文件时，要根据需求来保证何时将添加的数据同步到硬盘上，有以下同步选项： 选项 同步频率 always 每个写命令都同步 everysec 每秒同步一次 no 让操作系统来决定何时同步 always 选项会严重减低服务器的性能；everysec 选项比较合适，可以保证系统奔溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；no 选项并不能给服务器性能带来多大的提升，而且也会增加系统奔溃时数据丢失的数量。 随着服务器写请求的增多，AOF 文件会越来越大；Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。 复制通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。 一个从服务器只能有一个主服务器，并且不支持主主复制。 从服务器连接主服务器的过程 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令； 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令； 主服务器每执行一次写命令，就向从服务器发送相同的写命令。 主从链随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。 处理故障要用到持久化文件来恢复服务器的数据。 持久化文件可能因为服务器出错也有错误，因此要先对持久化文件进行验证和修复。对 AOF 文件就行验证和修复很容易，修复操作将第一个出错命令和其后的所有命令都删除；但是只能验证快照文件，无法对快照文件进行修复，因为快照文件进行了压缩，出现在快照文件中间的错误可能会导致整个快照文件的剩余部分无法读取。 当主服务器出现故障时，Redis 常用的做法是新开一台服务器作为主服务器，具体步骤如下：假设 A 为主服务器，B 为从服务器，当 A 出现故障时，让 B 生成一个快照文件，将快照文件发送给 C，并让 C 恢复快照文件的数据。最后，让 B 成为 C 的从服务器。 分片Redis 中的分片类似于 MySQL 的分表操作，分片是将数据划分为多个部分的方法，对数据的划分可以基于键包含的 ID、基于键的哈希值，或者基于以上两者的某种组合。通过对数据进行分片，用户可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。 假设有 4 个 Reids 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，… 等等，有不同的方式来选择一个指定的键存储在哪个实例中。最简单的方式是范围分片，例如用户 id 从 0~1000 的存储到实例 R0 中，用户 id 从 1001~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。 客户端分片 客户端使用一致性哈希等算法决定键应当分布到哪个节点。 代理分片 将客户端请求发送到代理上，由代理转发请求到正确的节点上。 服务器分片 Redis Cluster。 事件事件类型文件事件 服务器有许多套接字，事件产生时会对这些套接字进行操作，服务器通过监听套接字来处理事件。常见的文件事件有：客户端的连接事件；客户端的命令请求事件；服务器向客户端返回命令结果的事件； 时间事件 又分为两类：定时事件是让一段程序在指定的时间之内执行一次；周期性时间是让一段程序每隔指定时间就执行一次。 事件的调度与执行服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能监听太久，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。 事件调度与执行由 aeProcessEvents 函数负责，伪代码如下： 1234567891011121314151617181920212223def aeProcessEvents(): # 获取到达时间离当前时间最接近的时间事件 time_event = aeSearchNearestTimer() # 计算最接近的时间事件距离到达还有多少毫秒 remaind_ms = time_event.when - unix_ts_now() # 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0 if remaind_ms &lt; 0: remaind_ms = 0 # 根据 remaind_ms 的值，创建 timeval timeval = create_timeval_with_ms(remaind_ms) # 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定 aeApiPoll(timeval) # 处理所有已产生的文件事件 procesFileEvents() # 处理所有已到达的时间事件 processTimeEvents() 将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下： 1234567891011def main(): # 初始化服务器 init_server() # 一直处理事件，直到服务器关闭为止 while server_is_not_shutdown(): aeProcessEvents() # 服务器关闭，执行清理操作 clean_server() 从事件处理的角度来看，服务器运行流程如下： Redis 与 Memcached 的区别两者都是非关系型内存键值数据库。有以下主要不同： 数据类型 Memcached 仅支持字符串类型，而 Redis 支持五种不同种类的数据类型，使得它可以更灵活地解决问题。 数据持久化 Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。 分布式 Memcached 不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。 Redis Cluster 实现了分布式的支持。 内存管理机制 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘。而 Memcached 的数据则会一直在内存中。 Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。 Redis 适用场景缓存 适用 Redis 作为缓存，将热点数据放到内存中。 消息队列 Redis 的 List 类型是双向链表，很适合用于消息队列。 计数器 Redis 这种内存数据库才能支持计数器的频繁读写操作。 好友关系 使用 set 类型的交集很容易就可以知道两个用户的共同好友。 数据淘汰策略可以设置内存最大使用量，当内存使用量超过时施行淘汰策略，具体有 6 种淘汰策略。 策略 描述 volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰 volatile-random 从已设置过期时间的数据集中任意选择数据淘汰 allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰 allkeys-random 从所有数据集中任意选择数据进行淘汰 no-envicition 禁止驱逐数据 如果使用 Redis 来缓存数据时，要保证所有数据都是热点数据，可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。 一个简单的论坛系统分析该论坛系统功能如下： 可以发布文章； 可以对文章进行点赞； 在首页可以按文章的发布时间或者文章的点赞数进行排序显示； 文章信息文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。 Redis 没有关系型数据库中的表这一概念来将同类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。 点赞功能当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。 为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。 对文章进行排序为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的） 参考资料 Redis 实战 Reids 设计与实现 REDIS IN ACTION 论述 Redis 和 Memcached 的差异 Redis 3.0 中文版- 分片 Redis 应用场景 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP基础]]></title>
    <url>%2F2018%2F03%2F16%2FHTTP%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础概念 Web 基础 URL 请求和响应报文 HTTP 方法 GET：获取资源 POST：传输实体主体 HEAD：获取报文首部 PUT：上传文件 PATCH：对资源进行部分修改 DELETE：删除文件 OPTIONS：查询支持的方法 CONNECT：要求用隧道协议连接代理 TRACE：追踪路径 HTTP 状态码 2XX 成功 3XX 重定向 4XX 客户端错误 5XX 服务器错误 HTTP 首部 通用首部字段 请求首部字段 响应首部字段 实体首部字段 具体应用 Cookie 缓存 持久连接 编码 分块传输 多部分对象集合 范围请求 内容协商 虚拟主机 通信数据转发 HTTPs 加密 认证 完整性 各版本比较 HTTP/1.0 与 HTTP/1.1 的区别 HTTP/1.1 与 HTTP/2.0 的区别 参考资料 基础概念Web 基础 HTTP（HyperText Transfer Protocol，超文本传输协议）。 WWW（World Wide Web）的三种技术：HTML、HTTP、URL。 RFC（Request for Comments，征求修正意见书），互联网的设计文档。 URL URI（Uniform Resource Indentifier，统一资源标识符） URL（Uniform Resource Locator，统一资源定位符） URN（Uniform Resource Name，统一资源名称），例如 urn:isbn:0-486-27557-4 。 URI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 请求和响应报文请求报文 响应报文 HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET：获取资源POST：传输实体主体POST 主要目的不是获取资源，而是传输存储在内容实体中的数据。 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在内容实体。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 GET 的传参方式相比于 POST 安全性较差，因为 GET 传的参数在 URL 中是可见的，可能会泄露私密信息。并且 GET 只支持 ASCII 字符，如果参数为中文则可能会出现乱码，而 POST 支持标准字符集。 HEAD：获取报文首部和 GET 方法一样，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 PUT：上传文件由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; PATCH：对资源进行部分修改PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: "e0023aa4e"Content-Length: 100[description of changes] DELETE：删除文件与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 OPTIONS：查询支持的方法查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT：要求用隧道协议连接代理要求在于代理服务器通信时建立隧道，使用 SSL（Secure Sokets Layer，安全套接字）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE：追踪路径服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪），因此更不会去使用它。 HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求。响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会 在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-ModifiedSince，If-None-Match，If-Range，If-Unmodified-Since，但是不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝，服务器端没有必要给出拒绝的详细理由。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavilable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 HTTP 首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 各种首部字段及其含义如下（不需要全记，仅供查阅）： 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段；管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 具体应用CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送给客户端的数据，该数据会被保存在浏览器中，并且在下一次发送请求时包含该数据。通过 Cookie 可以让服务器知道两个请求是否来自于同一个客户端，从而实现保持登录状态等功能。 创建过程 服务器发送的响应报文包含 Set-Cookie 字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后发送请求时，会从浏览器中读出 Cookie 值，在请求报文中包含 Cookie 字段。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry Set-Cookie 属性 说明 NAME=VALUE 赋予 Cookie 的名称和其值（必需项） expires=DATE Cookie 的有效期（若不明确指定则默认为浏览器关闭前为止） path=PATH 将服务器上的文件目录作为 Cookie 的适用对象（若不指定则默认为文档所在的文件目录） domain=域名 作为 Cookie 适用对象的域名（若不指定则默认为创建 Cookie 的服务器的域名） Secure 仅在 HTTPS 安全通信时才会发送 Cookie HttpOnly 加以限制，使 Cookie 不能被 JavaScript 脚本访问 Session 和 Cookie 区别 Session 是服务器用来跟踪用户的一种手段，每个 Session 都有一个唯一标识：Session ID。当服务器创建了一个 Session 时，给客户端发送的响应报文就包含了 Set-Cookie 字段，其中有一个名为 sid 的键值对，这个键值对就是 Session ID。客户端收到后就把 Cookie 保存在浏览器中，并且之后发送的请求报文都包含 Session ID。HTTP 就是通过 Session 和 Cookie 这两种方式一起合作来实现跟踪用户状态的，Session 用于服务器端，Cookie 用于客户端。 浏览器禁用 Cookie 的情况 会使用 URL 重写技术，在 URL 后面加上 sid=xxx 。 使用 Cookie 实现用户名和密码的自动填写 网站脚本会自动从保存在浏览器中的 Cookie 读取用户名和密码，从而实现自动填写。 缓存优点 降低服务器的负担； 提高响应速度（缓存资源比服务器上的资源离客户端更近）。 实现方法 让代理服务器进行缓存； 让客户端浏览器进行缓存。 Cache-Control 字段 HTTP 通过 Cache-Control 首部字段来控制缓存。 1Cache-Control: private, max-age=0, no-cache no-cache 指令 该指令出现在请求报文的 Cache-Control 字段中，表示缓存服务器需要先向原服务器验证缓存资源是否过期； 该指令出现在响应报文的 Cache-Control 字段中，表示缓存服务器在进行缓存之前需要先验证缓存资源的有效性。 no-store 指令 该指令表示缓存服务器不能对请求或响应的任何一部分进行缓存。 no-cache 不表示不缓存，而是缓存之前需要先进行验证，no-store 才是不进行缓存。 max-age 指令 该指令出现在请求报文的 Cache-Control 字段中，如果缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 该指令出现在响应报文的 Cache-Control 字段中，表示缓存资源在缓存服务器中保存的时间。 Expires 字段也可以用于告知缓存服务器该资源什么时候会过期。在 HTTP/1.1 中，会优先处理 Cache-Control : max-age 指令；而在 HTTP/1.0 中，Cache-Control : max-age 指令会被忽略掉。 持久连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源，如果每进行一次 HTTP 通信就要断开一次 TCP 连接，连接建立和断开的开销会很大。持久连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 持久连接需要使用 Connection 首部字段进行管理。HTTP/1.1 开始 HTTP 默认是持久化连接的，如果要断开 TCP 连接，需要由客户端或者服务器端提出断开，使用 Connection : close；而在 HTTP/1.1 之前默认是非持久化连接的，如果要维持持续连接，需要使用 Connection : Keep-Alive。 管线化方式 可以同时发送多个请求和响应，而不需要发送一个请求然后等待响应之后再发下一个请求。 编码编码（Encoding）主要是为了对实体进行压缩。常用的编码有：gzip、compress、deflate、identity，其中 identity 表示不执行压缩的编码格式。 分块传输分块传输（Chunked Transfer Coding）可以把数据分割成多块，让浏览器逐步显示页面。 多部分对象集合一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name="submit-name"Larry--AaB03xContent-Disposition: form-data; name="files"; filename="file1.txt"Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求使得客户端能够只请求未发送的那部分数据，从而避免服务器端重新发送所有数据。 在请求报文首部中添加 Range 字段，然后指定请求的范围，例如 Range:bytes=5001-10000。请求成功的话服务器发送 206 Partial Content 状态。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 涉及以下首部字段：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language。 虚拟主机使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 通信数据转发代理 代理服务器接受客户端的请求，并且转发给其它服务器。 代理服务器一般是透明的，不会改变 URL。 使用代理的主要目的是：缓存、网络访问控制以及访问日志记录。 网关 与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。 隧道 使用 SSL 等加密手段，为客户端和服务器之间建立一条安全的通信线路。 HTTPsHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPs 并不是新协议，而是 HTTP 先和 SSL（Secure Socket Layer）通信，再由 SSL 和 TCP 通信。通过使用 SSL，HTTPs 提供了加密、认证和完整性保护。 加密有两种加密方式：对称密钥加密和公开密钥加密。对称密钥加密的加密和解密使用同一密钥，而公开密钥加密使用一对密钥用于加密和解密，分别为公开密钥和私有密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 对称密钥加密的缺点：无法安全传输密钥；公开密钥加密的缺点：相对来说更耗时。 HTTPs 采用 混合的加密机制 ，使用公开密钥加密用于传输对称密钥，之后使用对称密钥加密进行通信。（下图中，共享密钥即对称密钥） 认证通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPs 通信时，服务器会把证书发送给客户端，客户端取得其中的公开密钥之后，先进行验证，如果验证通过，就可以开始通信。 除了上诉提到的服务器端证书之外，还有客户端证书，客户端证书的目的就是让服务器对客户端进行验证。客户端证书需要用户自行安装，只有在业务需要非常高的安全性时才使用客户端证书，例如网上银行。 使用 OpenSSL 这套开源程序，每个人都可以构建一套属于自己的认证机构，从而自己给自己颁发服务器证书。浏览器在访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。 完整性SSL 提供摘要功能来验证完整性。 各版本比较HTTP/1.0 与 HTTP/1.1 的区别HTTP/1.1 新增了以下内容： 默认为长连接； 提供了范围请求功能； 提供了虚拟主机的功能； 多了一些缓存处理字段； 多了一些状态码； HTTP/1.1 与 HTTP/2.0 的区别多路复用 HTTP/2.0 使用多路复用技术，使用同一个 TCP 连接来处理多个请求。 首部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。 服务端推送 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 index.html 页面，服务端就把 index.js 一起发给客户端。 二进制格式 HTTP/1.1 的解析是基于文本的，而 HTTP/2.0 采用二进制格式。 参考资料 图解 HTTP MDN : HTTP 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F16%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[概述 匹配单个字符 匹配一组字符 使用元字符 匹配空白字符 匹配特定的字符类别 使用 POSIX 字符类 重复匹配 位置匹配 单词边界 字符串边界 使用子表达式 回溯引用 替换 大小写转换 前后查找 嵌入条件 回溯引用条件 前后查找条件 概述正则表达式用于文本内容的查找和替换。 正则表达式内置于其它语言或者软件产品中，它本身不是一种语言或者软件。 一个问题往往可以用多种正则表达式方案来解决。 正则表达式在线工具 匹配单个字符正则表达式一般是区分大小写的，但是也有些实现是不区分。 . 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符； \ 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \ 进行转义，即在 . 前面加上 \ 。 正则表达式 1nam. 匹配结果 My name is Zheng. 匹配一组字符[ ] 定义一个字符集合； 0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定。字符区间只能用在 [ ] 之间，因此 - 元字符只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符； ^ 是取非操作，必须在 [ ] 字符集合中使用； 应用 匹配以 abc 为开头，并且最后一个字母不为数字的字符串： 正则表达式 1abc[^0-9] 匹配结果 abcd abc1 abc2 使用元字符匹配空白字符 元字符 说明 [\b] 回退（删除）一个字符 \f 换页符 \n 换行符 \r 回车符 \t 制表符 \v 垂直制表符 \r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n ；\r\n\r\n 可以匹配 Windows 下的空白行，因为它将匹配两个连续的行尾标签，而这正是两条记录之间的空白行； . 是元字符，前提是没有对它们进行转义； f 和 n 也是元字符，但是前提是对他们进行了转义。 匹配特定的字符类别1. 数字元字符 元字符 说明 \d 数字字符，等价于 [0-9] \D 非数字字符，等价于 [^0-9] 2. 字母数字元字符 元字符 说明 \w 大小写字母，下划线和数字，等价于 [a-zA-Z0-9_] \W 对 \w 取非 3. 空白字符元字符 元字符 说明 \s 任何一个空白字符，等价于 [\f\n\r\t\v] \S 对 \s 取非 \x 匹配十六进制字符，\0 匹配八进制，例如 \x0A 对应 ASCII 字符 10 ，等价于 \n，也就是它会匹配 \n 。 使用 POSIX 字符类 字符类 说明 [:alnum:] 字母数字字符 [:alpha:] 字母字符 [:cntrl:] 控制字符 [:digit:] 数字字符 [:graph:] 非空白字符 ( 非空格、控制字符等 ) [:lower:] 小写字母 [:print:] 与 [:graph:] 相似，但是包含空格字符 [:punct:] 标点字符 [:space:] 所有的空白字符 ( 换行符、空格、制表符 ) [:upper:] 大写字母 [:xdigit:] 允许十六进制的数字 (0-9a-fA-F) 并不是所有正则表达式实现都支持 POSIX 字符类，也不一定使用它。 使用时需要用两对方括号，例如 [[:alpha:]]。 重复匹配+ 匹配 1 个或者多个字符， * 匹配 0 个或者多个，? 匹配 0 个或者 1 个。 应用 匹配邮箱地址。 正则表达式 1[\w.]+@\w+.\w+ [\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符； 匹配结果 abc.def@qq.com 为了可读性，常常把转义的字符放到字符集合 [ ] 中，但是含义是相同的。 12\w+@\w+.\w+[\w]+@[\w]+.[\w]+ {n} 匹配 n 个字符，{m, n} 匹配 m~n 个字符，{m,} 至少匹配 m 个字符； * 和 + 都是贪婪型元字符，会匹配最多的内容，在元字符后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。 正则表达式 1a.+c 由于 + 是贪婪型的，因此 .+ 会匹配更可能多的内容，所以会把整个 abcabcabc 文本都匹配，而不是只匹配前面的 abc 文本。用懒惰型可以实现匹配前面的。 匹配结果 abcabcabc 位置匹配单词边界\b 可以匹配一个单词的边界，边界是指位于 \w 和 \W 之间的位置；\B 匹配一个不是单词边界的位置。 \b 只匹配位置，不匹配字符，因此 \babc\b 匹配出来的结果为 3 个字符。 字符串边界^ 匹配整个字符串的开头，$ 匹配结尾。 ^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。 使用 (?m) 来打开分行匹配模式，在该模式下，换行被当做字符串的边界。 应用 匹配代码中以 // 开始的注释行 正则表达式 1(?m)^\s*//.*$ 如果没用 (?m)，则只会匹配 // 注释 1 以及之后的所有内容，因为 * 是贪婪型的。用了分行匹配模式之后，换行符被当成是字符串分隔符，因此能正确匹配出两个注释内容。 匹配结果 public void fun() { &nbsp;&nbsp;&nbsp;&nbsp; // 注释 1 &nbsp;&nbsp;&nbsp;&nbsp; int a = 1; &nbsp;&nbsp;&nbsp;&nbsp; int b = 2; &nbsp;&nbsp;&nbsp;&nbsp; // 注释 2 &nbsp;&nbsp;&nbsp;&nbsp; int c = a + b; } 使用子表达式使用 ( ) 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。 子表达式可以嵌套，但是嵌套层次过深会变得很难理解。 正则表达式 1(ab) &#123;2,&#125; 匹配结果 ababab | 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。 1(19|20)\d&#123;2&#125; 匹配结果 1900 2010 1020 应用 匹配 IP 地址。IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的： 一位或者两位的数字 1 开头的三位数 2 开头，第 2 位是 0-4 的三位数 25 开头，第 3 位是 0-5 的三位数 正则表达式 1(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))\.) &#123;3&#125;(((\d&#123;1,2&#125;)|(1\d&#123;2&#125;)|(2[0-4]\d)|(25[0-5]))) 匹配结果 192.168.0.1 555.555.555.555 回溯引用回溯引用使用 \n 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc ，那么回溯引用部分也需要匹配 abc 。 应用 匹配 HTML 中合法的标题元素。 正则表达式 \1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。 1&lt;(h[1-6])&gt;\w*?&lt;/\1&gt; 匹配结果 &lt;h1&gt;x&lt;/h1&gt; &lt;h2&gt;x&lt;/h2&gt; &lt;h3&gt;x&lt;/h1&gt; 替换需要用到两个正则表达式。 应用 修改电话号码格式。 文本 313-555-1234 查找正则表达式 1(\d&#123;3&#125;)(-)(\d&#123;3&#125;)(-)(\d&#123;4&#125;) 替换正则表达式 在第一个子表达式查找的结果加上 () ，然后加一个空格，在第三个和第五个字表达式查找的结果中间加上 - 进行分隔。 1($1) $3-$5 结果 (313) 555-1234 大小写转换 元字符 说明 \l 把下个字符转换为小写 \u 把下个字符转换为大写 \L 把\L 和\E 之间的字符全部转换为小写 \U 把\U 和\E 之间的字符全部转换为大写 \E 结束\L 或者\U 应用 把文本的第二个和第三个字符转换为大写。 文本 abcd 查找 1(\w)(\w&#123;2&#125;)(\w) 替换 1$1\U$2\E$3 结果 aBCd 前后查找前后查找规定了匹配的内容首尾应该匹配的内容，但是又不包含首尾匹配的内容。向前查找用 ?= 来定义，它规定了尾部匹配的内容，这个匹配的内容在 ?= 之后定义。所谓向前查找，就是规定了一个匹配的内容，然后以这个内容为尾部向前面查找需要匹配的内容。向后匹配用 ?&lt;= 定义。 应用 查找出邮件地址 @ 字符前面的部分。 正则表达式 1\w+(?=@) 结果 abc @qq.com 对向前和向后查找取非，只要把 = 替换成 ! 即可，比如 (?=) 替换成 (?!) 。取非操作使得匹配那些首尾不符合要求的内容。 嵌入条件回溯引用条件条件判断为某个子表达式是否匹配，如果匹配则需要继续匹配条件表达式后面的内容。 正则表达式 子表达式 (\() 匹配一个左括号，其后的 ? 表示匹配 0 个或者 1 个。 ?(1) 为条件，当子表达式 1 匹配时条件成立，需要执行 ) 匹配，也就是匹配右括号。 1(\()?abc(?(1)\)) 结果 (abc) abc (abc 前后查找条件条件为定义的首尾是否匹配，如果匹配，则继续执行后面的匹配。注意，首尾不包含在匹配的内容中。 正则表达式 ?(?=-) 为前向查找条件，只有在以 - 为前向查找的结尾能匹配 \d{5} ，才继续匹配 -\d{4} 。 1\d&#123;5&#125;(?(?=-)-\d&#123;4&#125;) 结果 11111 22222- 33333-4444 参考资料 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL基础]]></title>
    <url>%2F2018%2F03%2F16%2FSQL%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基础 创建表 插入 更新 删除 修改表 查询 排序 过滤 通配符 计算字段 函数 文本处理 日期和时间处理 数值处理 汇总 分组 子查询 连接 内连接 自连接 自然连接 外连接 组合查询 视图 存储过程 游标 触发器 事务处理 字符集 权限管理 基础模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。 主键的值不允许修改，也不允许复用（不能使用已经删除的主键值赋给新数据行的主键）。 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。 SQL 支持以下三种注释： 12345# 注释SELECT *FROM mytable; -- 注释/* 注释1 注释2 */ 创建表123456CREATE TABLE mytable ( id INT NOT NULL AUTO_INCREMENT, col1 INT NOT NULL DEFAULT 1, col2 VARCHAR(45) NULL, col3 DATE NULL, PRIMARY KEY (`id`)); 插入普通插入 12INSERT INTO mytable(col1, col2)VALUES(val1, val2); 插入检索出来的数据 123INSERT INTO mytable1(col1, col2)SELECT col1, col2FROM mytable2; 将一个表的内容复制到一个新表 12CREATE TABLE newtable ASSELECT * FROM mytable; 更新123UPDATE mytableSET col = valWHERE id = 1; 删除12DELETE FROM mytableWHERE id = 1; TRUNCATE TABLE 可以清空表，也就是删除所有行。 使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。 修改表添加列 12ALTER TABLE mytableADD col CHAR(20); 删除列 12ALTER TABLE mytableDROP COLUMN col; 删除表 1DROP TABLE mytable; 查询DISTINCT 相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。 12SELECT DISTINCT col1, col2FROM mytable; LIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。 返回前 5 行： 123SELECT *FROM mytableLIMIT 5; 123SELECT *FROM mytableLIMIT 0, 5; 返回第 3 ~ 5 行： 123SELECT *FROM mytableLIMIT 2, 3; 排序 ASC ：升序（默认） DESC ：降序 可以按多个列进行排序，并且为每个列指定不同的排序方式： 123SELECT *FROM mytableORDER BY col1 DESC, col2 ASC; 过滤不进行过滤的数据非常大，导致通过网络传输了很多多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 123SELECT *FROM mytableWHERE col IS NULL; 下表显示了 WHERE 子句可用的操作符 操作符 说明 = &lt; &gt; 等于 小于 大于 &lt;&gt; != 不等于 &lt;= !&gt; 小于等于 &gt;= !&lt; 大于等于 BETWEEN 在两个值之间 IS NULL 为NULL值 应该注意到，NULL 与 0 、空字符串都不同。 AND OR 用于连接多个过滤条件。优先处理 AND，因此当一个过滤表达式涉及到多个 AND 和 OR 时，应当使用 () 来决定优先级。 IN 操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 NOT 操作符用于否定一个条件。 通配符通配符也是用在过滤语句中，但它只能用于文本字段。 % 匹配 &gt;=0 个任意字符，类似于 *； _ 匹配 ==1 个任意字符，类似于 .； [ ] 可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。 使用 Like 来进行通配符匹配。 123SELECT *FROM mytableWHERE col LIKE '[^AB]%' -- 不以 A 和 B 开头的任意文本 不要滥用通配符，通配符位于开头处匹配会非常慢。 计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 12SELECT col1*col2 AS aliasFROM mytable Concat() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 12SELECT Concat(TRIM(col1), ' (', TRIM(col2), ')')FROM mytable 函数各个 DBMS 的函数都是不相同的，因此不可移植。 文本处理 函数 说明 LEFT() RIGHT() 左边或者右边的字符 LOWER() UPPER() 转换为小写或者大写 LTRIM() RTIM() 去除左边或者右边的空格 LENGTH() 长度 SUNDEX() 转换为语音值 其中， SOUNDEX() 是将一个字符串转换为描述其语音表示的字母数字模式的算法，它是根据发音而不是字母比较。 123SELECT *FROM mytableWHERE SOUNDEX(col1) = SOUNDEX('apple') 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 12mysql&gt; SELECT NOW(); -&gt; '2017-06-28 14:01:52' 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。 使用 DISTINCT 可以汇总函数值汇总不同的值。 12SELECT AVG(DISTINCT col1) AS avg_colFROM mytable 分组分组就是把具有相同的数据值的行放在同一组中。 可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。 指定的分组字段除了能让数组按该字段进行分组，也可以按该字段进行排序，例如按 col 字段排序并分组数据： 123SELECT col, COUNT(*) AS numFROM mytableGROUP BY col; WHERE 过滤行，HAVING 过滤分组。行过滤应当先与分组过滤； 12345SELECT col, COUNT(*) AS numFROM mytableWHERE col &gt; 2GROUP BY colHAVING COUNT(*) &gt;= 2; GROUP BY 的排序结果为分组字段，而 ORDER BY 也可以以聚集字段来进行排序。 1234SELECT col, COUNT(*) AS numFROM mytableGROUP BY colORDER BY num; 分组规定： GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前； 除了汇总计算语句的字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出； NULL 的行会单独分为一组； 大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。 子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 1234SELECT *FROM mytable1WHERE col1 IN (SELECT col2 FROM mytable2); 下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次： 123456SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM CustomersORDER BY cust_name; 连接连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 Where。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123select a, b, cfrom A inner join Bon A.key = B.key 可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123select a, b, cfrom A, Bwhere A.key = B.key 在没有条件语句的情况下返回笛卡尔积。 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 123456select namefrom employeewhere department = ( select department from employee where name = "Jim"); 自连接版本 1234select namefrom employee as e1, employee as e2where e1.department = e2.department and e1.name = "Jim"; 连接一般比子查询的效率高。 自然连接自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。 内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。 12select *from employee natural join department; 外连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123select Customers.cust_id, Orders.order_num from Customers left outer join Orders on Customers.cust_id = Orders.curt_id; 如果需要统计顾客的订单数，使用聚集函数。 12345select Customers.cust_id, COUNT(Orders.order_num) as num_ordfrom Customers left outer join Orderson Customers.cust_id = Orders.curt_idgroup by Customers.cust_id; 组合查询使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果为 M+N 行。 每个查询必须包含相同的列、表达式或者聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 1234567SELECT colFROM mytableWHERE col = 1UNIONSELECT colFROM mytableWHERE col =2; 视图视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 视图具有如下好处： 简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 1234CREATE VIEW myview ASSELECT Concat(col1, col2) AS concat_col, col3*col4 AS count_colFROM mytableWHERE col5 = val; 存储过程存储过程可以看成是对一系列 SQL 操作的批处理； 使用存储过程的好处 代码封装，保证了一定的安全性； 代码复用； 由于是预先编译，因此具有很高的性能。 创建存储过程 命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。 包含 in、out 和 inout 三种参数。 给变量赋值都需要用 select into 语句。 每次只能给一个变量赋值，不支持集合的操作。 1234567891011delimiter //create procedure myprocedure( out ret int ) begin declare y int; select sum(col1) from mytable into y; select y*y into ret; end //delimiter ; 12call myprocedure(@ret);select @ret; 游标在存储过程中使用游标可以对一个结果集进行移动遍历。 游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。 使用游标的四个步骤： 声明游标，这个过程没有实际检索出数据； 打开游标； 取出数据； 关闭游标； 1234567891011121314151617181920delimiter //create procedure myprocedure(out ret int) begin declare done boolean default 0; declare mycursor cursor for select col1 from mytable; # 定义了一个continue handler，当 sqlstate '02000' 这个条件出现时，会执行 set done = 1 declare continue handler for sqlstate '02000' set done = 1; open mycursor; repeat fetch mycursor into ret; select ret; until done end repeat; close mycursor; end // delimiter ; 触发器触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE 触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化。 INSERT 触发器包含一个名为 NEW 的虚拟表。 12CREATE TRIGGER mytrigger AFTER INSERT ON mytableFOR EACH ROW SELECT NEW.col; DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。 UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改地，而 OLD 是只读的。 可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。 MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。 事务处理基本术语 事务（transaction）指一组 SQL 语句； 回退（rollback）指撤销指定 SQL 语句的过程； 提交（commit）指将未存储的 SQL 语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CRETE 和 DROP 语句。 MySQL 的事务提交默认是隐式提交，也就是每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。 通过设置 autocommit 为 0 可以取消自动提交，直到 autocommit 被设置为 1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。 如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。 1234567START TRANSACTION// ...SAVEPOINT delete1// ...ROLLBACK TO delete1// ...COMMIT 字符集基本术语 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对字符指定如何比较，主要用于排序和分组。 除了给表指定字符集和校对外，也可以给列指定： 123CREATE TABLE mytable(col VARCHAR(10) CHARACTER SET latin COLLATE latin1_general_ci )DEFAULT CHARACTER SET hebrew COLLATE hebrew_general_ci; 可以在排序、分组时指定校对： 123SELECT *FROM mytableORDER BY col COLLATE latin1_general_ci; 权限管理MySQL 的账户信息保存在 mysql 这个数据库中。 12USE mysql;SELECT user FROM user; 创建账户 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 新创建的账户没有任何权限。 修改账户名 1RENAME myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 1GRANT SELECT, INSERT ON mydatabase.* TO myuser; 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 删除权限 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 更改密码 必须使用 Password() 函数 1SET PASSWROD FOR myuser = Password('newpassword'); 参考资料 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式基础]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本概念 1. 异常 1.1 服务器宕机 1.2 网络异常 1.3 磁盘故障 2. 超时 3. 衡量指标 3.1 性能 3.2 可用性 3.3 一致性 3.4 可扩展性 数据分布 1. 哈希分布 2. 顺序分布 负载均衡 复制 1. 强同步复制协议 2. 异步复制协议 CAP BASE 1. 基本可用 2. 软状态 3. 最终一致性 容错 1. 故障检测 2. 故障恢复 CDN 架构 参考资料 基本概念1. 异常1.1 服务器宕机内存错误、服务器停电等都会导致服务器宕机，此时节点无法正常工作，称为不可用。 服务器宕机会导致节点失去所有内存信息，因此需要将内存信息保存到持久化介质上。 1.2 网络异常有一种特殊的网络异常称为 网络分区 ，即集群的所有节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。 1.3 磁盘故障磁盘故障是一种发生概率很高的异常。 使用冗余机制，将数据存储到多台服务器。 2. 超时在分布式系统中，一个请求除了成功和失败两种状态，还存在着超时状态。 可以将服务器的操作设计为具有 幂等性 ，即执行多次的结果与执行一次的结果相同。如果使用这种方式，当出现超时的时候，可以不断地重新请求直到成功。 3. 衡量指标3.1 性能常见的性能指标有：吞吐量、响应时间。 其中，吞吐量指系统在某一段时间可以处理的请求总数，通常为每秒的读操作数或者写操作数；响应时间指从某个请求发出到接收到返回结果消耗的时间。 这两个指标往往是矛盾的，追求高吞吐的系统，往往很难做到低响应时间，解释如下： 在无并发的系统中，吞吐量为响应时间的倒数，例如响应时间为 10 ms，那么吞吐量为 100 req/s，因此高吞吐也就意味着低响应时间。 但是在并发的系统中，由于一个请求在调用 I/O 资源的时候，需要进行等待。服务器端一般使用的是异步等待方式，即等待的请求被阻塞之后不需要一直占用 CPU 资源。这种方式能大大提高 CPU 资源的利用率，例如上面的例子中，单个请求在无并发的系统中响应时间为 10 ms，如果在并发的系统中，那么吞吐量将大于 100 req/s。因此为了追求高吞吐量，通常会提高并发程度。但是并发程度的增加，会导致请求的平均响应时间也增加，因为请求不能马上被处理，需要和其它请求一起进行并发处理，响应时间自然就会增高。 3.2 可用性可用性指系统在面对各种异常时可以提供正常服务的能力。可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。 3.3 一致性可以从两个角度理解一致性：从客户端的角度，读写操作是否满足某种特性；从服务器的角度，多个数据副本之间是否一致。 有以下三种一致性模型： 强一致性：新数据写入之后，在任何数据副本上都能读取到最新值； 弱一致性：新数据写入之后，不能保证在数据副本上能读取到最新值； 最终一致性：新数据写入之后，只能保证过一了一个时间窗口才能读取到最新值； 3.4 可扩展性指系统通过扩展集群服务器规模来提高性能的能力。理想的分布式系统需要实现“线性可扩展”，即随着集群规模的增加，系统的整体性能也会线程增加。 数据分布分布式系统的数据分布在多个节点中，常用的数据分布方式有哈希分布和顺序分布。 1. 哈希分布哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。 传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。 一致性哈希 Distributed Hash Table（DHT）：对于哈希空间 0~2n，将该哈希空间看成一个哈希环，将每个节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。 一致性哈希的优点是在加入或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将数据对象 C 重新存放到节点 X 上即可，对于节点 A、B、D 都没有影响。 2. 顺序分布哈希分布式破坏了数据的有序性，顺序分布则不会。 顺序分布的数据划分为多个连续的部分，按一定策略分布到不同节点上。例如下图中，User 表的主键范围为 1 ~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 ~ 1000，1001 ~ 2000，…，6001 ~ 7000。 其中 Meta 表是为了支持更大的集群规模，它将原来的一层索引结分成两层，使用 Meta 表来维护 User 子表所在的节点，从而减轻 Root 节点的负担。 负载均衡衡量负载的因素很多，如 CPU、内存、磁盘等资源使用情况、读写请求数等。分布式系统应当能够自动负载均衡，当某个节点的负载较高，将它的部分数据迁移到其它节点。 每个集群都有一个总控节点，其它节点为工作节点，由总控节点根据全局负载信息进行整体调度，工作节点定时发送心跳包（Heartbeat）将节点负载相关的信息发送给总控节点。 一个新上线的工作节点，由于其负载较低，如果不加控制，总控节点会将大量数据同时迁移到该节点上，造成该节点一段时间内无法工作。因此负载均衡操作需要平滑进行，新加入的节点需要较长的一段时间来达到比较均衡的状态。 复制复制是保证分布式系统高可用的基础，让一个数据存储多个副本，当某个副本所在的节点出现故障时，能够自动切换到其它副本上，从而实现故障恢复。 多个副本通常有一个为主副本，其它为备副本。主副本用来处理写请求，备副本主要用来处理读请求，实现读写分离。主副本将同步操作日志发送给备副本，备副本通过回放操作日志获取最新修改。 主备副本之间有两种复制协议，一种是强同步复制协议，一种是异步复制协议。 1. 强同步复制协议要求主副本将同步操作日志发给备副本之后进行等待，要求至少一个备副本返回成功后，才开始修改主副本，修改完成之后通知客户端操作成功。 优点：至少有一个备副本拥有完整的数据，出现故障时可以安全地切换到该备副本，因此一致性好。 缺点：可用性差，因为主副本需要等待，那么整个分布式系统的可用时间就会降低。 2. 异步复制协议主副本将同步操作日志发给备副本之后不需要进行等待，直接修改主副本并通知客户端操作成功。 优点：可用性好。 缺点：一致性差。 CAP分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition tolerance），最多只能同时满足其中两项。这三个概念上文中已经提到。 在设计分布式系统时，需要根据实际需求弱化某一要求。因此就有了下图中的三种设计：CA、CP 和 AP。 需要注意的是，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此实际上设计分布式系统需要在一致性和可用性之间做权衡。 BASEBASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。BASE 理论是对 CAP 中一致性和可用性权衡的结果，是基于 CAP 定理逐步演化而来的。BASE 理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 1. 基本可用指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。 例如，电商在做促销时，服务层可能只提供降级服务，部分用户可能会被引导到降级页面上。 2. 软状态指允许系统存在中间状态，而该中间状态不会影响系统整体可用性，即不同节点的数据副本之间进行同步的过程允许存在延时。 3. 最终一致性指所有的数据副本，在经过一段时间的同步之后，最终都能够达到一致的状态。 强一致性需要保证数据副本实时一致，而最终一致性只需要保证过一段时间是一致的。 ACID 是传统数据库系统常用的设计理论，追求强一致性模型。BASE 常用于大型分布式系统，只需要保证最终一致性。在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。 容错分布式系统故障发生的概率很大，为了实现高可用以及减少人工运维成本，需要实现自动化容错。 1. 故障检测通过 租约机制 来对故障进行检测。假设节点 A 为主控节点，节点 A 向节点 B 发送租约，节点 B 在租约规定的期限内才能提供服务。期限快到达时，节点 B 需要向 A 重新申请租约。 如果过期，那么 B 不再提供服务，并且 A 也能知道 B 此时可能发生故障并已经停止服务。可以看到，通过这种机制，A 和 B 都能对 B 发生故障这一事实达成一致。 2. 故障恢复当某个节点故障时，就将它上面的服务迁移到其它节点。 CDN 架构CND 通过将内容发布到靠近用户的边缘节点，使不同地域的用户在访问相同网页时可以就近获取。不仅可以减轻服务器的负担，也可以提高用户的访问速度。 从下图可以看出，DNS 在对域名解析时不再向用户返回源服务器的 IP 地址，而是返回边缘节点的 IP 地址，所以用户最终访问的是边缘节点。边缘节点会先从源服务器中获取用户所需的数据，如果请求成功，边缘节点会将页面缓存下来，下次用户访问时可以直接读取。 参考资料 杨传辉. 大规模分布式存储系统: 原理解析与架构实战[M]. 机械工业出版社, 2013. 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统原理]]></title>
    <url>%2F2018%2F03%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务四大特性 1. 原子性 2. 一致性 3. 隔离性 4. 持久性 数据不一致 1. 丢失修改 2. 读脏数据 3. 不可重复读 隔离级别 1. 未提交读（READ UNCOMMITTED） 2. 提交读（READ COMMITTED） 3. 可重复读（REPEATABLE READ） 4. 可串行化（SERIALIXABLE） 可串行化调度 封锁类型 封锁粒度 封锁协议 三级封锁协议 两段锁协议 乐观锁和悲观锁 悲观锁 乐观锁 MySQL 隐式和显示锁定 范式 第一范式 (1NF) 第二范式 (2NF) 第三范式 (3NF) BC 范式（BCNF） 约束 键码 单值约束 引用完整性约束 域约束 一般约束 数据库的三层模式和两层映像 外模式 模式 内模式 外模式/模式映像 模式/内模式映像 ER 图 实体的三种联系 表示出现多次的关系 联系的多向性 表示子类 一些概念 参考资料 事务四大特性1. 原子性事务被视为不可分割的最小单元，要么全部提交成功，要么全部失败回滚。 2. 一致性事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。 3. 隔离性一个事务所做的修改在最终提交以前，对其它事务是不可见的。也可以理解为多个事务单独执行，互不影响。 4. 持久性一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。持久性通过数据库备份和恢复来保证。 数据不一致1. 丢失修改T1 和 T2 两个事务同时对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。 2. 读脏数据T1 修改后写入数据库，T2 读取这个修改后的数据，但是如果 T1 撤销了这次修改，使得 T2 读取的数据是脏数据。 3. 不可重复读T1 读入某个数据，T2 对该数据做了修改，如果 T1 再读这个数据，该数据已经改变，和最开始读入的是不一样的。 隔离级别数据库管理系统需要防止出现数据不一致问题，并且有多种级别可以实现，这些级别称为隔离级别。 1. 未提交读（READ UNCOMMITTED）事务中的修改，即使没有提交，对其它事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。 2. 提交读（READ COMMITTED）一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所在的修改在提交之前对其它事务是不可见的。这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。 3. 可重复读（REPEATABLE READ）解决了脏读的问题，保证在同一个事务中多次读取同样的记录结果是一致的。 但是会出现幻读的问题，所谓幻读，指的是某个事务在读取某个范围内的记录时，另一个事务会在范围内插入数据，当之前的事务再次读取该范围的记录时，会产生幻行。 4. 可串行化（SERIALIXABLE）强制事务串行执行，避免幻读。 可串行化调度如果并行的事务的执行结果和某一个串行的方式执行的结果一样，那么可以认为结果是正确的。 封锁类型排它锁 (X 锁）和共享锁 (S 锁），又称写锁和读锁。 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁； 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。 封锁粒度应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作，包括获取锁，检查所是否已经解除、释放锁，都会增加系统开销。因此封锁粒度越小，系统开销就越大。需要在锁开销以及数据安全性之间做一个权衡。 MySQL 中主要提供了两种封锁粒度：行级锁以及表级锁。 封锁协议三级封锁协议一级封锁协议 事务 T 要修改数据 A 时必须加 X 锁，直到事务结束才释放锁。 可以解决丢失修改问题； 二级封锁协议 在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。 可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。 三级封锁协议 在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。 可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。 两段锁协议加锁和解锁分为两个阶段进行。两段锁是并行事务可串行化的充分条件，但不是必要条件。 1lock-x(A)...lock-s(B)...lock-s(c)...unlock(A)...unlock(C)...unlock(B) 乐观锁和悲观锁悲观锁假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。 Java synchronized 就属于悲观锁的一种实现，每次线程要修改数据时都先获得锁，保证同一时刻只有一个线程能操作数据，其他线程则会被阻塞。 乐观锁假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 Java JUC 中的 Atomic 包就是乐观锁的一种实现，AtomicInteger 通过 CAS（Compare And Set）操作实现线程安全的自增操作。 乐观锁有两种实现方式，数据版本和时间戳。它们都需要在数据库表中增加一个字段，使用这个字段来判断数据是否过期。例如，数据版本实现方式中，需要在数据库表中增加一个数字类型的 version 字段，当读取数据时，将 version 字段的值一同读出。随后数据每更新一次，对此 version 值加 1。当提交更新的时候，判断读出的 version 和数据库表中的 version 是否一致，如果一致，则予以更新；否则认为是过期数据。 MySQL 隐式和显示锁定MySQL InnoDB 采用的是两阶段锁协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放。前面描述的锁定都是隐式锁定，InnoDB 会根据事务隔离级别在需要的时候自动加锁。 另外，InnoDB 也支持通过特定的语句进行显示锁定，这些语句不属于 SQL 规范： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE 范式记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。 如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。 对于 W-&gt;A，如果能找到 W 的真子集 W’，使得 W’-&gt; A，那么 W-&gt;A 就是部分函数依赖，否则就是完全函数依赖； 以下关系中，Sno 表示学号，Sname 表示学生姓名，Sdept 表示学院，Cname 表示课程名，Mname 表示院长姓名。函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname}。 不符合范式的关系，会产生很多异常。主要有以下四种异常： 冗余数据 修改异常 删除异常 插入异常，比如如果新插入一个学生的信息，而这个学生还没选课，那么就无法插入该学生。 关系数据库的范式理论就是是为了解决这四种异常。 高级别范式的依赖基于低级别的范式。 第一范式 (1NF)属性不可分。 第二范式 (2NF)每个非主属性完全函数依赖于键码。 可以通过分解来满足。 分解前 分解后 第三范式 (3NF)非主属性不传递依赖于键码。 上述 S1 存在传递依赖，Mname 依赖于 Sdept，而 Sdept 又依赖于 Sno，可以继续分解。 BC 范式（BCNF）所有属性不传递依赖于键码。 关系模式 STC(Sname, Tname, Cname, Grade)，其中四个属性分别为学生姓名、教师姓名、课程名和成绩。有以下函数依赖： 分解成 SC(Sname, Cname, Grade) 和 ST(Sname, Tname)，对于 ST，属性之间是多对多关系，无函数依赖。 约束键码用于唯一表示一个实体。 键码可以由多个属性构成，每个构成键码的属性称为码。 单值约束某个属性的值是唯一的。 引用完整性约束一个实体的属性引用的值在另一个实体的某个属性中存在。 域约束某个属性的值在特定范围之内。 一般约束一般性约束，比如大小约束，数量约束。 数据库的三层模式和两层映像 外模式：局部逻辑结构 模式：全局逻辑结构 内模式：物理结构 外模式又称用户模式，是用户和数据库系统的接口，特定的用户只能访问数据库系统提供给他的外模式中的数据。例如不同的用户创建了不同数据库，那么一个用户只能访问他有权限访问的数据库。 一个数据库可以有多个外模式，一个用户只能有一个外模式，但是一个外模式可以给多个用户使用。 模式可以分为概念模式和逻辑模式，概念模式可以用概念-关系来描述；逻辑模式使用特定的数据模式（比如关系模型）来描述数据的逻辑结构，这种逻辑结构包括数据的组成、数据项的名称、类型、取值范围。不仅如此，逻辑模式还要描述数据之间的关系，数据的完整性与安全性要求。 内模式又称为存储模式，描述记录的存储方式，例如索引的组织方式、数据是否压缩以及是否加密等等。 外模式/模式映像把外模式的局部逻辑结构和模式的全局逻辑结构联系起来。该映像可以保证数据和应用程序的逻辑独立性。 模式/内模式映像把模式的全局逻辑结构和内模式的物理结构联系起来，该映像可以保证数据和应用程序的物理独立性。 ER 图Entity-Relationship，有三个组成部分：实体、属性、联系。 实体的三种联系联系包含 1 对 1，1 对多，多对多三种。 如果 A 到 B 是 1 对多关系，那么画个带箭头的线段指向 B；如果是 1 对 1，画两个带箭头的线段；如果是多对多，画两个不带箭头的线段。下图的 Course 和 Student 是 1 对多的关系。 表示出现多次的关系一个实体在联系出现几次，就要用几条线连接。下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。 联系的多向性虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。 一般只使用二元联系，可以把多元关系转换为二元关系。 表示子类用 IS-A 联系来表示子类，具体做法是用一个三角形和两条线来连接类和子类。与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。 一些概念数据模型 由数据结构、数据操作和完整性三个要素组成。 数据库系统 数据库系统包含所有与数据库相关的内容，包括数据库、数据库管理系统、应用程序以及数据库管理员和用户，还包括相关的硬件和软件。 参考资料 史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006. 施瓦茨. 高性能MYSQL(第3版)[M]. 电子工业出版社, 2013. MySQL 乐观锁与悲观锁 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统]]></title>
    <url>%2F2018%2F03%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[第一章 概述 操作系统基本特征 1. 并发 2. 共享 3. 虚拟 4. 异步 系统调用 中断分类 1. 外中断 2. 异常 3. 陷入 大内核和微内核 1. 大内核 2. 微内核 第二章 进程管理 进程与线程 1. 进程 2. 线程 3. 区别 进程状态的切换 调度算法 1. 批处理系统中的调度 1.1 先来先服务 1.2 短作业优先 1.3 最短剩余时间优先 2. 交互式系统中的调度 2.1 优先级调度 2.2 时间片轮转 2.3 多级反馈队列 3. 实时系统中的调度 进程同步 1. 临界区 2. 同步与互斥 3. 信号量 4. 管程 进程通信 1. 管道 2. 信号量 3. 消息队列 4. 信号 5. 共享内存 6. 套接字 经典同步问题 1. 读者-写者问题 2. 哲学家进餐问题 第三章 死锁 死锁的必要条件 死锁的处理方法 1. 鸵鸟策略 2. 死锁检测与死锁恢复 2.1 每种类型一个资源的死锁检测 2.2 每种类型多个资源的死锁检测 2.3 死锁恢复 3. 死锁预防 3.1 破坏互斥条件 3.2 破坏占有和等待条件 3.3 破坏不可抢占条件 3.4 破坏环路等待 4. 死锁避免 4.1 安全状态 4.2 单个资源的银行家算法 4.3 多个资源的银行家算法 第四章 存储器管理 虚拟内存 分页与分段 1. 分页 2. 分段 3. 段页式 4. 分页与分段区别 页面置换算法 1. 最佳（Optimal） 2. 先进先出（FIFO） 3. 最近最久未使用（LRU, Least Recently Used） 4. 时钟（Clock） 第五章 设备管理 磁盘调度算法 1. 先来先服务（FCFS, First Come First Serverd） 2. 最短寻道时间优先（SSTF, Shortest Seek Time First） 3. 扫描算法（SCAN） 4. 循环扫描算法（CSCAN） 参考资料 第一章 概述操作系统基本特征1. 并发并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线或者多处理器。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享共享是指系统中的资源可以供多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。 3. 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。 主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。 4. 异步异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 系统调用如果一个进程在用户态需要用到操作系统的一些功能，就需要使用系统调用从而陷入内核，由操作系统代为完成。 可以由系统调用请求的功能有设备管理、文件管理、进程管理、进程通信、存储器管理等。 中断分类1. 外中断由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 2. 异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入在用户程序中使用系统调用。 大内核和微内核1. 大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。 由于各模块共享信息，因此有很高的性能。 2. 微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 第二章 进程管理进程与线程1. 进程进程是操作系统进行资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 2. 线程一个进程中可以有多个线程，线程是独立调度的基本单位。 同一个进程中的多个线程之间可以并发执行，它们共享进程资源。 3. 区别 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。 举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 进程状态的切换阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU，缺少 CPU 会让进程从运行态转换为就绪态。 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 调度算法需要针对不同环境来讨论调度算法。 1. 批处理系统中的调度1.1 先来先服务first-come first-serverd（FCFS）。 调度最先进入就绪队列的作业。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先shortest job first（SJF）。 调度估计运行时间最短的作业。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先shortest remaining time next（SRTN）。 2. 交互式系统中的调度2.1 优先级调度除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。 响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间 这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。 2.2 时间片轮转将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，进程切换太频繁，在进程切换上就会花过多时间。 2.3 多级反馈队列如果一个进程需要执行 100 个时间片，如果采用轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要 7 （包括最初的装入）的交换。 每个队列的优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 3. 实时系统中的调度实时系统要求一个服务请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步1. 临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section;// exit section 2. 同步与互斥 同步指多个进程按一定顺序执行； 互斥指多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量信号量（Semaphore） 是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，将进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，并且唤醒睡眠的进程，让进程完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125;void P2() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 需要使用一个互斥量 mutex 来对缓冲区这个临界资源进行互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进行中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty = 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，empty 永远都为 0，那么生产者和消费者就会一直等待下去，造成死锁。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE)&#123; int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE)&#123; down(&amp;full); down(&amp;mutex); int item = remove_item(); up(&amp;mutex); up(&amp;empty); consume_item(item); &#125;&#125; 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码中的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来让另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 使用管程实现生成者-消费者问题 123456789101112131415161718192021222324252627282930313233343536373839monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 进程通信进程通信可以看成是不同进程间的线程通信，对于同一个进程内线程的通信方式，主要使用信号量、条件变量等同步机制。 1. 管道写进程在管道的尾端写入数据，读进程在管道的首端读出数据。管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。 Linux 中管道是通过空文件来实现。 管道有三种： 普通管道：有两个限制，一是只能单向传输；二是只能在父子进程之间使用； 流管道：去除第一个限制，支持双向传输； 命名管道：去除第二个限制，可以在不相关进程之间进行通信。 2. 信号量信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止一个进程正在访问共享资源时，其它进程也访问该资源。主要作为进程间以及同一进程内不同线程之间的同步手段。 3. 消息队列消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 4. 信号信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 5. 共享内存共享内存就是映射一段能被其它进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。 共享内存是最快的 IPC 方式，它是针对其它 IPC 运行效率低而专门设计的。它往往与其它通信机制（如信号量）配合使用，来实现进程间的同步和通信。 6. 套接字套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。 经典同步问题生产者和消费者问题前面已经讨论过了。 1. 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123; while(TRUE) &#123; down(&amp;count_mutex); count++; if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count == 0) up(&amp;data_mutex); up(&amp;count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; down(&amp;data_mutex); write(); up(&amp;data_mutex); &#125;&#125; 2. 哲学家进餐问题五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起筷子左右的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) &#123; while(TRUE) &#123; think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); &#125;&#125; 为了防止死锁的发生，可以两个条件： 必须同时拿起左右两个筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(); take_two(i); eat(); put_tow(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);&#125;void put_tow(i) &#123; down(&amp;mutex); state[i] = THINKING; text(LEFT); test(RIGHT); up(&amp;mutex);&#125;void test(i) &#123; // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 第三章 死锁死锁的必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁的处理方法1. 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 2. 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 2.1 每种类型一个资源的死锁检测上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 2.2 每种类型多个资源的死锁检测上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A = (2 2 2 0)。P1 可以执行，执行后释放 P1 拥有的资源，A = (4 2 2 2) ，P2 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 2.3 死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 3. 死锁预防在程序运行之前预防发生死锁。 3.1 破坏互斥条件例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 3.2 破坏占有和等待条件一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 3.3 破坏不可抢占条件3.4 破坏环路等待给资源统一编号，进程只能按编号顺序来请求资源。 4. 死锁避免在程序运行时避免发生死锁。 4.1 安全状态图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 4.2 单个资源的银行家算法一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 4.3 多个资源的银行家算法上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 第四章 存储器管理虚拟内存每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到一部分不在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 分页与分段1. 分页大部分虚拟内存系统都使用分页技术。把由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。例如有一台计算机可以产生 16 位地址，它的虚拟地址空间为 0~64K，然而计算机只有 32KB 的物理内存，因此虽然可以编写 64KB 的程序，但它们不能被完全调入内存运行。 虚拟地址空间划分成固定大小的页，在物理内存中对应的单元称为页框，页和页框大小通常相同，它们之间通过页表进行映射。 程序最开始只将一部分页调入页框中，当程序引用到没有在页框的页时，产生缺页中断，进行页面置换，按一定的原则将一部分页框换出，并将页调入。 2. 分段上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 每个段都需要程序员来划分。 3. 段页式用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。 用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。 程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。 4. 分页与分段区别 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 页面置换算法在程序运行过程中，若其所要访问的页面不在内存而需要把它们调入内存，但是内存已无空闲空间时，系统必须从内存中调出一个页面到磁盘对换区中，并且将程序所需要的页面调入内存中。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳（Optimal）所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间会被再访问到。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 进程运行时，先将 7,0,1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 先进先出（FIFO）所选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 3. 最近最久未使用（LRU, Least Recently Used）虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面的页面号总是在栈顶，而最近最久未使用的页面的页面号总是在栈底。 4. 时钟（Clock）Clock 页面置换算法需要用到一个访问位，当一个页面被访问时，将访问位置为 1。 首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。 第五章 设备管理磁盘调度算法当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。磁盘调度的主要目标是使磁盘的平均寻道时间最少。 1. 先来先服务（FCFS, First Come First Serverd）根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先（SSTF, Shortest Seek Time First）要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。 3. 扫描算法（SCAN）SSTF 会出现饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。 SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。 当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。 4. 循环扫描算法（CSCAN）CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001. Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统. 进程间的几种通信方式 转载自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络基础]]></title>
    <url>%2F2018%2F03%2F16%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[第一章 概述 网络的网络 ISP 互联网的组成 主机之间的通信方式 电路交换与分组交换 1. 电路交换 2. 报文交换 3. 分组交换 时延 1. 发送时延 2. 传播时延 3. 处理时延 4. 排队时延 计算机网络体系结构* 1. 七层协议 2. 五层协议 3. 数据在各层之间的传递过程 4. TCP/IP 体系结构 第二章 物理层 通信方式 带通调制 信道复用技术 1. 频分复用、时分复用 2. 统计时分复用 3. 波分复用 4. 码分复用 第三章 数据链路层 三个基本问题 1. 封装成帧 2. 透明传输 3. 差错检测 点对点信道 - PPP 协议 局域网的拓扑 广播信道 - CSMA/CD 协议* 扩展局域网* 1. 在物理层进行扩展 2. 在链路层进行扩展 3. 虚拟局域网 MAC 层* 第四章 网络层* 网际协议 IP 概述 IP 数据报格式 IP 地址编址 1. 分类 2. 子网划分 3. 无分类 IP 地址和 MAC 地址 地址解析协议 ARP 路由器的结构 路由器分组转发流程 路由选择协议 1. 内部网关协议 RIP 2. 内部网关协议 OSPF 3. 外部网关协议 BGP 网际控制报文协议 ICMP 分组网间探测 PING IP 多播 虚拟专用网 VPN 网络地址转换 NAT 第五章 运输层* UDP 和 TCP 的特点 UDP 首部格式 TCP 首部格式 TCP 的三次握手 TCP 的四次挥手 TCP 滑动窗口 TCP 可靠传输 TCP 流量控制 TCP 拥塞控制 慢开始与拥塞避免 快重传与快恢复 第六章 应用层* 域名系统 DNS 1. 层次结构 2. 解析过程 文件传输协议 FTP 远程终端协议 TELNET 万维网 WWW 电子邮件协议 POP3 IMAP SMTP 动态主机配置协议 DHCP 点对点传输 P2P Web 页面请求过程 1. DHCP 配置主机信息 2. ARP 解析 MAC 地址 3. DNS 解析域名 4. HTTP 请求页面 常用端口 参考资料 第一章 概述网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为主干 ISP、地区 ISP 和本地 ISP。 互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 互联网的组成 边缘部分：所有连接在互联网上的主机，用户可以直接使用； 核心部分：由大量的网络和连接这些网络的路由器组成，为边缘部分的主机提供服务。 主机之间的通信方式1. 客户-服务器（C/S） 客户是服务的请求方，服务器是服务的提供方。 2. 对等（P2P） 不区分客户和服务器。 电路交换与分组交换1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 报文交换报文交换用于邮局通信系统，邮局接收到一份报文之后，先存储下来，然后把相同目的地的报文一起转发到下一个目的地，这个过程就是存储转发过程。 3. 分组交换分组交换也使用了存储转发，但是转发的是分组而不是报文。把整块数据称为一个报文，由于一个报文可能很长，需要先进行切分，来满足分组能处理的大小。在每个切分的数据前面加上首部之后就成为了分组，首部包含了目的地址和源地址等控制信息。 存储转发允许在一条传输线路上传送多个主机的分组，因此两个用户之间的通信不需要占用端到端的线路资源。 相比于报文交换，由于分组比报文更小，因此分组交换的存储转发速度更加快速。 时延总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 1. 发送时延主机或路由器发送数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示发送速率。 2. 传播时延电磁波在信道中传播一定的距离需要花费的时间，电磁波传播速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速率。 3. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部，从分组中提取数据部分等。 4. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构*1. 七层协议如图 a 所示，其中表示层和会话层用途如下： 表示层：信息的语法、语义以及它们的关联，如加密解密、转换翻译、压缩解压缩； 会话层：不同机器上的用户之间建立及管理会话。 2. 五层协议 应用层：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层：为主机之间提供服务，而不是像运输层协议那样是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组来进行传输。 数据链路层：网络层针对的还是主机之间，而主机之间可以有很多链路，链路层协议就是为相邻结点之间提供服务。数据链路层把网络层传来的分组封装成帧。 物理层：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使物理层上的数据链路层感觉不到这些差异。 3. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 4. TCP/IP 体系结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 现在的 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP/IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 第二章 物理层通信方式 单向通信，又称为单工通信； 双向交替通信，又称为半双工通信； 双向同时通信，又称为全双工通信。 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 信道复用技术1. 频分复用、时分复用频分复用的所有用户在相同的时间占用不同的频率带宽资源；时分复用的所有用户在不同的时间占用相同的频率带宽资源。 使用这两种方式进行通信，在通信的过程中用户会一直占用一部分信道资源。但是由于计算机数据的突发性质，没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 2. 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 3. 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 4. 码分复用为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 和 有 为了方便，取 m=8，设码片 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 其中 为 的反码。 利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 第三章 数据链路层三个基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧中有首部和尾部，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据中出现首部尾部相同的内容前面插入转义字符，如果需要传输的内容正好就是转义字符，那么就在转义字符前面再加个转义字符，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 点对点信道 - PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议就是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 &lt; 在 PPP 的帧中 F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 局域网的拓扑广播信道 - CSMA/CD 协议*在广播信道上，同一时间只能允许一台计算机发送数据。 CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多计算机以多点的方式连接到总线上。 载波监听 ：每个站都必须不停地监听信道。在发送前，如果检听信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听 到信道已有其它站正在发送数据，就表示发生了碰撞。虽然每一个站在发送数据之前都已经检听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定，从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 扩展局域网*1. 在物理层进行扩展使用集线器进行扩展。 集线器的主要功能是对接收到的信号进行放大，以扩大网络的传输距离。 集线器不能根据 MAC 地址进行转发，而是以广播的方式发送数据帧。 集线器是一种共享式的传输设备，意味着同一时刻只能传输一组数据帧。 2. 在链路层进行扩展最开始使用的是网桥，它收到一个帧时，根据帧的 MAC 地址，查找网桥中的地址表，然后确定将帧转发到哪一个接口。 网桥不是共享式设备，因此性能比集线器这种共享式设备更高。 交换机的问世很快就淘汰了网桥，它实质上是一个多接口网桥，而网桥是两接口。交换机的每个接口都能直接与一个主机或者另一个交换机相连，并且一般都工作在全双工方式。 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到 接口的映射。下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，因此就把帧发送给主机 A，同时交换机添加主机 B 到接口 3 的映射。 3. 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息，例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 MAC 层*MAC 地址是 6 字节（48 位）的地址，用于唯一表示网络适配器（网卡），一台主机拥有多少个适配器就有多少个 MAC 地址，例如笔记本电脑普遍存在无线网络适配器和有线网络适配器。 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 前同步码 ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 第四章 网络层*网际协议 IP 概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选部分的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 IP 地址编址IP 地址的编址方式经历了三个历史阶段： 分类； 子网划分； 无分类。 1. 分类由两部分组成，网络号和主机号，其中不同类别具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。注意，外部网络看不到子网的存在。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 IP 地址和 MAC 地址网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 地址解析协议 ARP实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。 路由器的结构路由器从功能上可以划分为两大部分：路由选择和分组转发。 分组转发部分由三部分组成：交换结构、一组输入端口和一组输出端口。 交换结构的交换网络有以下三种实现方式： 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。（路由表项是网络号而不是 IP 地址，这样做大大减少了路由表条目数量） 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议互联网使用的路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 内部网关协议 IGP（Interior Gateway Protocol）：在 AS 内部使用，如 RIP 和 OSPF。 外部网关协议 EGP（External Gateway Protocol）：在 AS 之间使用，如 BGP。 1. 内部网关协议 RIPRIP 是一种分布式的基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1，跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小，但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPAS 之间的路由选择很困难，主要是互联网规模很大。并且各个 AS 内部使用不同的路由选择协议，就无法准确定义路径的度量。并且 AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。它采用路径向量路由选择协议。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 分组网间探测 PINGPING 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 PING 的过程： PING 同一个网段的主机：查找目的主机的 MAC 地址，然后直接交付。如果无法查找到 MAC 地址，就要进行一次 ARP 请求。 PING 不同网段的主机：发送到网关让其进行转发。同样要发送到网关也需要通过查找网关的 MAC 地址，根据 MAC 地址进行转发。 IP 多播在一对多的通信中，多播不需要将分组复制多份，从而大大节约网络资源。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信部经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 第五章 运输层*网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。 运输层提供了应用进程间的逻辑通信。运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看见的好像在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据包协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）。 传输控制协议 TCP（Transmission Control Protocol） 是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块） UDP 首部格式首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和而临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放运输连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。 B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 TCP 的四次挥手以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文段，FIN=1； B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据； 当 B 要不再需要连接时，发送连接释放请求报文段，FIN=1； A 收到后发出确认，此时连接释放。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间。这么做有两个理由： 确保最后一个确认报文段能够到达。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，A 等待一段时间就是为了处理这种情况的发生。 可能存在“已失效的连接请求报文段”，为了防止这种报文段出现在本次连接之外，需要等待一段时间。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 32, 34, 35}，其中 {31, 32} 按序到达，而 {34, 35} 就不是，因此只对字节 32 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 超时时间 RTO 应该略大于 RRTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差，它与新的 RRT 和 RRTs 有关。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。例如将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接受，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四种算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护有一个叫做拥塞窗口（cwnd）的状态变量。注意拥塞窗口与发送方窗口的区别，拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 快重传与快恢复在接收方，要求每次接收到报文段都应该发送对已收到有序报文段的确认，例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以确认下一个报文段丢失，例如收到三个 M2 ，则 M3 丢失。此时执行快重传，立即重传下一个报文段。 在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 第六章 应用层*域名系统 DNS把主机名解析为 IP 地址。 被设计成分布式系统。 1. 层次结构一个域名由多个层次构成，从上层到下层分别为顶级域名、二级域名、三级域名以及四级域名。所有域名可以画成一颗域名树。 域名服务器可以分为以下四类： 根域名服务器：解析顶级域名； 顶级域名服务器：解析二级域名； 权限域名服务器：解析区内的域名； 本地域名服务器：也称为默认域名服务器。可以在其中配置高速缓存。 区和域的概念不同，可以在一个域中划分多个区。图 b 在域 abc.com 中划分了两个区：abc.com 和 y.abc.com 因此就需要两个权限域名服务器： 2. 解析过程主机向本地域名服务器解析的过程采用递归，而本地域名服务器向其它域名服务器解析可以使用递归和迭代两种方式。 迭代的方式下，本地域名服务器向一个域名服务器解析请求解析之后，结果返回到本地域名服务器，然后本地域名服务器继续向其它域名服务器请求解析；而递归地方式下，结果不是直接返回的，而是继续向前请求解析，最后的结果才会返回。 文件传输协议 FTPFTP 在运输层使用 TCP，并且需要建立两个并行的 TCP 连接：控制连接和数据连接。控制连接在整个会话期间一直保持打开，而数据连接在数据传送完毕之后就关闭。控制连接使用端口号 21，数据连接使用端口号 20。 远程终端协议 TELNETTELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 万维网 WWWHTTP 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件发送协议和读取协议。其中发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不去手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。IMAP 协议也支持创建自定义的文件夹。 SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主题的结构，定义了非 ASCII 码的编码规则。 动态主机配置协议 DHCPDHCP 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、默认路由器 IP 地址、域名服务器的 IP 地址。 工作方式如下：需要 IP 地址的主机广播发送 DHCP 发现报文（将目的地址置为全 1，即 255.255.255.255:67，源地址设置为全 0，即 0.0.0.0:68），DHCP 服务器收到发现报文之后，则在 IP 地址池中取一个地址，发送 DHCP 提供报文给该主机。 点对点传输 P2P把某个文件分发的所有对等集合称为一个洪流。文件的数据单元称为文件块，它的大小是固定的。一个新的对等方加入某个洪流，一开始并没有文件块，但是能够从其它对等方中逐渐地下载到一些文件块，与此同时，它也为别的对等方上传一些文件块。 每个洪流都有一个基础设施，称为追踪器。当一个对等方加入洪流时，必须向追踪器登记，并周期性地通知追踪器它仍在洪流中。可以在任何时间加入和退出某个洪流。 一个新的对等方加入洪流时，追踪器会随机从洪流中选择若干个对等方，并让新对等方与这些对等方建立连接，把这些对等方称为相邻对等方。接收和发送文件块都是在相邻对等方中进行。 当一个对等方需要很多文件块时，通过使用最稀有优先的策略来取得文件块，也就是一个文件块在相邻对等方中副本最少，那么就优先请求这个文件块。 当很多对等方向同一个对等方请求文件块时，该对等方优先选择以最高速率向其发送文件块的对等方。 P2P 是一个分布式系统，任何时候都有对等方加入或者退出。使用分布式散列表 DHT，可以查找洪流中的资源和 IP 地址映射。 Web 页面请求过程1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYNACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 常用端口 应用层协议 端口号 运输层协议 DNS 53 UDP FTP 控制连接 21，数据连接 20 TCP TELNET 23 TCP DHCP 67 68 UDP HTTP 80 TCP SMTP 25 TCP POP3 110 TCP IMAP 143 TCP 参考资料 计算机网络 第七版 计算机网络 自顶向下方法 资料摘自https://github.com/CyC2018]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MinDoc接口管理文档]]></title>
    <url>%2F2018%2F03%2F16%2FMinDoc%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[需求介绍项目组内部需要一款简单实用的项目接口文档管理和分享的系统.功能: 用来存储日常接口文档,数据库字典,手册说明等文档; 需要内置项目管理,用户管理,权限管理等功能,满足大部分中小团队的文档管理需求. MinDoc在Windows下的安装1 下载可执行文件请从 https://github.com/lifei6671/mindoc/releases 下载最新版的可执行文件，一般文件名为 mindoc_windows_amd.zip . 2 解压压缩包请将刚才下载的文件解压，推荐使用好压解压到任意目录。建议不用用中文目录名称。 3 创建数据库在这里采用sqlite数据库,将 conf/app.conf 中的数据库配置成如下,系统会自动创建 sqlite 数据库文件：12db_adapter=sqlite3db_database=mindoc_db 4 配置数据库 配置文件: 12db_adapter=sqlite3db_database=./conf/mindoc_db 初始化数据库: 1mindoc_windows_amd64.exe install 自动生成管理员账号:admin 密码:123456 5 启动程序双击mindoc_windows_amd64.exe,访问 http://127.0.0.1:8181 6 导出pdf 安装whtmltopdf,下载解压到目录;whtmltopdf的下载地址:https://wkhtmltopdf.org/downloads.html。下载后,安装即可; 配置文件,指定whtmltopdf路径: 1wkhtmltopdf=C:/Program Files/wkhtmltopdf/bin/wkhtmltopdf.exe 7 安装go环境(如果电脑不存在go环境)下载地址:https://github.com/lifei6671/mindoc/blob/master/lib/time/zoneinfo.zip?raw=true设置环境变量:键名为 ZONEINFO，值为MinDoc跟目录下的/lib/time/zoneinfo.zip 绝对路径。]]></content>
      <categories>
        <category>基础设施</category>
      </categories>
      <tags>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务号开发]]></title>
    <url>%2F2018%2F03%2F15%2F%E6%9C%8D%E5%8A%A1%E5%8F%B7%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[服务号后台配置 公众号后台 域名备案 DNS域名解析 前端开发后端开发部署]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>公众号</tag>
      </tags>
  </entry>
</search>
